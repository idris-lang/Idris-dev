Automatically generated by Mendeley 1.6
Any changes to this file will be lost if it is regenerated by Mendeley.

@article{McBride2007,
author = {McBride, Conor and Paterson, Ross},
file = {:Users/edwin/Documents/Mendeley Desktop/McBride, Paterson/Applicative programming with effects/McBride, Paterson - Applicative programming with effects - 2008.pdf:pdf},
journal = {Journal of functional programming},
number = {1},
pages = {1----13},
title = {{Applicative programming with effects}},
url = {http://journals.cambridge.org/abstract_S0956796807006326},
volume = {18},
year = {2008}
}
@inproceedings{McBride2006,
author = {McBride, C and Goguen, H and McKinna, J},
booktitle = {Types for Proofs and Programs {(TYPES 2006)}},
title = {{A few constructions on constructors}},
url = {http://www.springerlink.com/index/P4863U0M41396254.pdf},
year = {2006}
}
@article{McBride2005,
author = {McBride, Conor},
editor = {Vene, Varmo and Uustalu, Tarmo},
isbn = {3540285407},
journal = {Advanced Functional Programming},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
pages = {130--170},
publisher = {Springer},
series = {Lecture Notes in Computer Science},
title = {{Epigram: Practical programming with dependent types}},
url = {http://www.springerlink.com/index/96j7v5vn8tyebeky.pdf},
volume = {3622},
year = {2005}
}
@article{Okasaki1993,
author = {Okasaki, Chris},
file = {:Users/edwin/Documents/Mendeley Desktop/Okasaki/Red-Black Trees in A Functional Setting/Okasaki - Red-Black Trees in A Functional Setting - 1993.pdf:pdf},
journal = {Journal of functional programming},
title = {{Red-Black Trees in A Functional Setting}},
year = {1993}
}
@inproceedings{Hancock2000,
author = {Hancock, Peter and Setzer, Anton},
booktitle = {{Proceedings of the 14th Annual Conference of the EACSL on Computer Science Logic}},
file = {:Users/edwin/Documents/Mendeley Desktop/Hancock, Setzer/Interactive Programs in Dependent Type Theory/Hancock, Setzer - Interactive Programs in Dependent Type Theory - 2000.pdf:pdf},
isbn = {3-540-67895-6},
month = aug,
pages = {317--331},
title = {{Interactive Programs in Dependent Type Theory}},
url = {http://dl.acm.org/citation.cfm?id=647850.737221},
year = {2000}
}
@article{Turner2004,
author = {Turner, D A},
file = {:Users/edwin/Documents/Mendeley Desktop/Turner/Total Functional Programming/Turner - Total Functional Programming - 2004.pdf:pdf},
journal = {Journal of Universal Computer Science},
keywords = {functional programming},
number = {7},
pages = {751----768},
title = {{Total Functional Programming}},
volume = {10},
year = {2004}
}
@phdthesis{norell2007thesis,
author = {Norell, Ulf},
file = {:Users/edwin/Documents/Mendeley Desktop/Norell/Towards a practical programming language based on dependent type theory/Norell - Towards a practical programming language based on dependent type theory - 2007.pdf:pdf},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
publisher = {Citeseer},
school = {Chalmers University of Technology},
title = {{Towards a practical programming language based on dependent type theory}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.7934&amp;rep=rep1&amp;type=pdf},
year = {2007}
}
@article{Wu,
annote = {1,3

        
This paper describes a solution, in Haskell, of the 2012 ICFP Programming Contest task, explaining in particular how Haskell's laziness and higher order functions helped to build a solution in limited time. I enjoyed reading this paper as an experience report - it provides evidence for the importance of high level features such as purity and laziness (for example when describing the GameTrie), and shows that Haskell can handle more realistic, practical, problems such as concurrency and exceptions (for example when dealing gracefully with timeout and communication between solving threads).

        
My main concern with the paper is that it reads as if the reader is already familiar with the contest task. It would be useful to be more precise about the task itself in the introduction, rather than by making it implicit from the code samples. Section 1.1 describes the problem, but only in general terms - I think it would be worth extending this, and correspondingly removing some of the code. In particular, 'stepRobot' and 'updRocks' would probably be fine just with their type signatures if the problem specification was more precise.

      },
author = {Wu, Nicolas and Magalh\~{a}es, Jos\'{e} Pedro and Bransen, Jeroen and Swierstra, Wouter},
file = {:Users/edwin/Documents/Mendeley Desktop/Wu et al/Pure and Lazy Lambda Mining/Wu et al. - Pure and Lazy Lambda Mining - Unknown.pdf:pdf},
title = {{Pure and Lazy Lambda Mining}}
}
@inproceedings{NanevskiAAMorrisett2008,
abstract = {We describe an axiomatic extension to the Coq proof assistant, that supports writing, reasoning about, and extracting higher-order, dependently-typed programs with side-effects. Coq already includes a powerful functional language that supports dependent types, but that language is limited to pure, total functions. The key contribution of our extension, which we call Ynot, is the added support for computations that may have effects such as non-termination, accessing a mutable store, and throwing/catching exceptions. The axioms of Ynot form a small trusted computing base which has been formally justified in our previous work on Hoare Type Theory (HTT). We show how these axioms can be combined with the powerful type and abstraction mechanisms of Coq to build higher-level reasoning mechanisms which in turn can be used to build realistic, verified software components. To substantiate this claim, we describe here a representative series of modules that implement imperative finite maps, including support for a higher-order (effectful) iterator. The implementations range from simple (e.g., association lists) to complex (e.g., hash tables) but share a common interface which, abstracts the implementation details and ensures that the modules properly implement the finite map abstraction. Copyright 2008 ACM.},
author = {{Nanevski A A Morrisett}, G B Shinnar A B Govereau P B Birkedal L C},
booktitle = {International Conference on Functional Programming},
doi = {10.1145/1411204.1411237},
file = {:Users/edwin/Documents/Mendeley Desktop/Nanevski A A Morrisett/Ynot Dependent types for imperative programs/Nanevski A A Morrisett - Ynot Dependent types for imperative programs - 2008.pdf:pdf},
isbn = {9781595939197},
issn = {15232867},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
number = {9},
pages = {229--240},
title = {{Ynot: Dependent types for imperative programs}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650032847&partnerID=40&md5=7a5be3083878399cebafda33b1affa6b},
volume = {43},
year = {2008}
}
@article{Walt,
annote = {-1, 5

        
This paper describes the use of Agda's reflection mechanism to help with proof automation, and gives some simple examples, including proving evenness of natural numbers and proving that a boolean formula is a tautology.

        
It seems that proof automation is important for a practical language with dependent types, and Agda's reflection mechanism as described is likely to help. However, this paper only really scratches the surface of what is possible - existing (unpublished, as far as I'm aware) examples such as the Ring solver go much further towards demonstrating its value.

        
The 'Evenness' example uses a lot of space for something pretty simple. An in practice, the number won't necessarily be known. What if you know "Even x" and need to prove "Even (x + 100)". Does it still work? Similarly for the tautology example - what if there is an unknown formula which is nevertheless known to be a tautology? It would be nice, therefore, to show how such proof obligations come up in practice and how the reflection techniques described help. Without this, it's not clear that the paper answers the given central question of whether Agda's reflective capabilities are sufficient and practically usable.

        
In summary: there's some nice tutorial material here describing reflection and its application, but I don't think there is enough depth for it to be really interesting.

        
Minor comments

        
The fonts and layout look wrong. Is this the proper LaTeX class? Also remember that the colour won't come out in print...

        
p2 "new" keywords seems wrong for a technique was has been aroundfor a couple of years. I know it hasn't been written up elsewhere, but I'd omit the word "new"

        
p3 "This is why we have decidable equality" - can you explain what you mean by this, for the non-Agda expert?

        
Vars are naturals - so they are de Bruijn indexed?

        
p5 "Other terms are rejected" - what does it mean for a term to be rejected? i.e. what is the effect? The text hints that this is a type error, since there is a suggestion that a proof is needed to show it is valid, but it would be good to be explicit.

        
p8 I'm not sure I'd go as far as to say it's "trivial" to show that (1) is a tautology, but I agree it should be easy, if tedious.},
author = {Walt, Paul Van Der and Swierstra, Wouter},
file = {:Users/edwin/Documents/Mendeley Desktop/Walt, Swierstra/Engineering Proof by Reflection in Agda/Walt, Swierstra - Engineering Proof by Reflection in Agda - Unknown.pdf:pdf},
title = {{Engineering Proof by Reflection in Agda}}
}
@misc{Haskell98,
    author = {{Peyton-Jones}, Simon and Hughes, John and Augustsson, Lennart and Barton, Dave and Boutel, Brian and Burton, Warren and Fasel, Joseph and Hammond, Kevin and Hinze, Ralf and Hudak, Paul and Johnsson, Thomas and Jones, Mark and Launchbury, John and Meijer, Erik and Peterson, John and Reid, Alastair and Runciman, Colin and Wadler, Philip},
    citeulike-article-id = {4034405},
    comment = {Available from \url{http://www.haskell.org/onlinereport/}},
    keywords = {file-import-09-02-11, postdoc\_bib},
    posted-at = {2009-02-11 10:55:50},
    priority = {2},
    title = {{The Haskell 98 Report}},
    year = {1999}
}
@inproceedings{madhavapeddy2007melange,
author = {Madhavapeddy, A. and Ho, A. and Deegan, T. and Scott, D. and Sohan, R.},
booktitle = {ACM SIGOPS Operating Systems Review},
file = {:Users/edwin/Documents/Mendeley Desktop/Madhavapeddy et al/Melange creating a functional internet/Madhavapeddy et al. - Melange creating a functional internet - 2007.pdf:pdf},
number = {3},
pages = {101--114},
publisher = {ACM},
title = {{Melange: creating a functional internet}},
url = {http://dl.acm.org/citation.cfm?id=1273009},
volume = {41},
year = {2007}
}
@inproceedings{czarnecki2004dsl,
author = {Czarnecki, K. and O’Donnell, J. and Striegnitz, J. and Taha, W.},
booktitle = {Domain-Specific Program Generation},
file = {:Users/edwin/Documents/Mendeley Desktop/Czarnecki et al/DSL implementation in MetaOCaml, Template Haskell, and C/Czarnecki et al. - DSL implementation in MetaOCaml, Template Haskell, and C - 2004.pdf:pdf},
pages = {51--72},
publisher = {Springer},
title = {{DSL implementation in MetaOCaml, Template Haskell, and C++}},
url = {http://www.springerlink.com/index/NL620EL7N94M161H.pdf},
year = {2004}
}
@article{Wadler2001,
abstract = {The use of monads to structure functional programs is described. Monads provide a convenient framework for simulating effects found in other languages, such as global state, exception handling, output, or non-determinism. Three case studies are looked at in detail: how monads ease the modification of a simple evaluator; how monads act as the basis of a datatype of arrays subject to in-place update; and how monads can be used to build parsers.},
author = {Wadler, Philip},
doi = {10.1007/3-540-59451-5_2},
editor = {Jeuring, Johan and Meijer, Erik},
file = {:Users/edwin/Documents/Mendeley Desktop/Wadler/Monads for functional programming/Wadler - Monads for functional programming - 2001.pdf:pdf},
isbn = {3540594515},
issn = {03029743},
journal = {Advanced Functional Programming},
number = {August 1992},
pages = {24--52},
publisher = {Springer},
series = {Lecture Notes in Computer Science},
title = {{Monads for functional programming}},
url = {http://www.springerlink.com/index/715264614rh13340.pdf},
volume = {925},
year = {2001}
}
@phdthesis{Boquist1999,
author = {Boquist, Urban},
file = {:Users/edwin/Documents/Mendeley Desktop/Boquist/Code optimisation techniques for lazy functional languages/Boquist - Code optimisation techniques for lazy functional languages - 1999.pdf:pdf},
title = {{Code optimisation techniques for lazy functional languages}},
url = {http://mirror.seize.it/papers/Code Optimization Techniques for Lazy Functional Languages.pdf},
year = {1999}
}
@inproceedings{Taha2003,
author = {Taha, Walid and Nielsson, Michael Florentin},
booktitle = {Principles of Programming Languages},
file = {:Users/edwin/Documents/Mendeley Desktop/Taha, Nielsson/Environment Classifiers/Taha, Nielsson - Environment Classifiers - 2003.pdf:pdf},
isbn = {1581136285},
keywords = {linear,modal logic,multi-stage programming,temporal logic,type safety,type systems},
title = {{Environment Classifiers}},
year = {2003}
}
@article{Brady2012a,
author = {{Peyton Jones}, S.L.},
doi = {10.1093/geront/gns026},
file = {:Users/edwin/Documents/Mendeley Desktop/Peyton Jones/Beautiful Code Chapter 24/Peyton Jones - Beautiful Code Chapter 24 - 2012.pdf:pdf},
isbn = {9780596510046},
issn = {1758-5341},
journal = {The Gerontologist},
month = dec,
number = {6},
pages = {NP},
pmid = {23150082},
title = {{Beautiful Code Chapter 24}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23150082},
volume = {52},
year = {2012}
}
@article{mcbride2010ornamental,
author = {McBride, Conor},
file = {:Users/edwin/Documents/Mendeley Desktop/McBride/Ornamental algebras, algebraic ornaments/McBride - Ornamental algebras, algebraic ornaments - 2010.pdf:pdf},
journal = {Journal of Functional Programming},
title = {{Ornamental algebras, algebraic ornaments}},
url = {http://personal.cis.strath.ac.uk/$\sim$conor/pub/OAAO/Ornament.pdf},
year = {2010}
}
@inproceedings{Gall2012,
author = {Gall, Yann Le and Lee, Adam J and Kapdia, Apu},
booktitle = {SCMAT},
file = {:Users/edwin/Documents/Mendeley Desktop/Gall, Lee, Kapdia/PlexC A Policy Language for Exposure Control/Gall, Lee, Kapdia - PlexC A Policy Language for Exposure Control - 2012.pdf:pdf},
isbn = {9781450312950},
keywords = {exposure,policy languages,privacy},
pages = {219--228},
title = {{PlexC : A Policy Language for Exposure Control}},
year = {2012}
}
@article{Campbell-moore,
author = {Campbell-moore, Catrin},
file = {:Users/edwin/Documents/Mendeley Desktop/Campbell-moore/A Computable Infinitary Logic/Campbell-moore - A Computable Infinitary Logic - Unknown.pdf:pdf},
pages = {1--10},
title = {{A Computable Infinitary Logic}}
}
@misc{Resolution2012a,
author = {Fall, Kevin R and Stevens, W. Richard},
doi = {10.1093/epirev/mxr031},
file = {:Users/edwin/Documents/Mendeley Desktop/Fall, Stevens/TCPIP Illustrated Volume 1 Chapter 11/Fall, Stevens - TCPIP Illustrated Volume 1 Chapter 11 - Unknown.pdf:pdf},
issn = {1478-6729},
pmid = {22215642},
title = {{TCP/IP Illustrated Volume 1 Chapter 11}}
}
@inproceedings{Pasalic2002,
author = {Pa\v{s}alic, Emir and Taha, Walid and Sheard, Tim},
booktitle = {International Conference on Functional Programming},
doi = {10.1145/583852.581499},
file = {:Users/edwin/Documents/Mendeley Desktop/Pa\v{s}alic, Taha, Sheard/Tagless staged interpreters for typed languages/Pa\v{s}alic, Taha, Sheard - Tagless staged interpreters for typed languages - 2002.pdf:pdf},
isbn = {1-58113-487-8},
issn = {03621340},
keywords = {calculus of constructions,definitional interpreters,domain-specific languages,multi-stage programming},
month = sep,
number = {9},
pages = {218--229},
title = {{Tagless staged interpreters for typed languages}},
url = {http://dl.acm.org/citation.cfm?id=583852.581499},
volume = {37},
year = {2002}
}
@book{Projects,
author = {Hunt, Andrew and Thomas, David},
file = {:Users/edwin/Documents/Mendeley Desktop/Hunt, Thomas/The Pragmatic Programmer Chapter 8/Hunt, Thomas - The Pragmatic Programmer Chapter 8 - Unknown.pdf:pdf},
isbn = {020161622X},
title = {{The Pragmatic Programmer Chapter 8}}
}
@inproceedings{Wadler1989,
abstract = {From the type of a polymorphic function we can derive a theorem that it satisfies. Every function of the same type satisfies the same theorem. This provides a free source of useful theorems, courtesy of Reynolds' abstraction theorem for the polymorphic lambda calculus.},
author = {Wadler, Philip},
booktitle = {Proceedings of the fourth international conference on Functional programming languages and computer architecture},
doi = {10.1145/99370.99404},
file = {:Users/edwin/Documents/Mendeley Desktop/Wadler/Theorems for free!/Wadler - Theorems for free! - 1989.pdf:pdf},
isbn = {0897913280},
number = {June},
pages = {347--359},
publisher = {ACM},
series = {FPCA '89},
title = {{Theorems for free!}},
url = {http://portal.acm.org/citation.cfm?id=99404},
year = {1989}
}
@inproceedings{swierstra2007beauty,
author = {Swierstra, W. and Altenkirch, T.},
booktitle = {Proceedings of the ACM SIGPLAN workshop on Haskell workshop},
file = {:Users/edwin/Documents/Mendeley Desktop/Swierstra, Altenkirch/Beauty in the beast/Swierstra, Altenkirch - Beauty in the beast - 2007.pdf:pdf},
pages = {25--36},
publisher = {ACM},
title = {{Beauty in the beast}},
url = {http://dl.acm.org/citation.cfm?id=1291206},
year = {2007}
}
@inproceedings{Xi1999,
abstract = {Note: OCR errors may be found in this Reference List extracted from the full text article. ACM has opted to expose the complete List rather than only correct and linked references.},
author = {Xi, Hongwei and Pfenning, Frank},
booktitle = {Proceedings of the 26th ACM SIGPLANSIGACT symposium on Principles of programming languages POPL 99},
doi = {10.1145/292540.292560},
file = {:Users/edwin/Documents/Mendeley Desktop/Xi, Pfenning/Dependent types in practical programming/Xi, Pfenning - Dependent types in practical programming - 1999.pdf:pdf},
isbn = {1581130953},
issn = {07439016},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
organization = {Carnegie Mellon University},
pages = {214--227},
publisher = {ACM Press},
series = {POPL '99},
title = {{Dependent types in practical programming}},
url = {http://portal.acm.org/citation.cfm?doid=292540.292560},
volume = {26},
year = {1999}
}
@inproceedings{Kimmell2012,
author = {Kimmell, G and Stump, A and {Eades III}, HD and Fu, Peng and Sheard, Tim and Weirich, S and Casinghino, C and Sj\"{o}berg, V and Collins, N and Ahn, KY},
booktitle = {{Proceedings of the 6th {ACM} workshop on Programming Languages Meets Program Verification - PLPV '12}},
file = {:Users/edwin/Documents/Mendeley Desktop/Kimmell et al/Equational reasoning about programs with general recursion and call-by-value semantics/Kimmell et al. - Equational reasoning about programs with general recursion and call-by-value semantics - 2012.pdf:pdf},
title = {{Equational reasoning about programs with general recursion and call-by-value semantics}},
url = {http://dl.acm.org/citation.cfm?id=2103780},
year = {2012}
}
@article{mccann2000packet,
author = {McCann, P.J. and Chandra, S.},
journal = {ACM SIGCOMM Computer Communication Review},
number = {4},
pages = {321--333},
publisher = {ACM},
title = {{Packet types: abstract specification of network protocol messages}},
url = {http://dl.acm.org/citation.cfm?id=347563},
volume = {30},
year = {2000}
}
@misc{Ferreira2012,
annote = {This paper explains how to compile Beluga, a programming language with higher order abstract syntax which is specifically designed to support data structures with binders. In particular, it aims to make it easy to reason about metatheory of programming languages by supporting name generation, alpha conversion and capture avoiding substitution.

        
In general, I liked this paper, primarily because it tackles an underrepresented problem - namely, taking a high level language with support for theorem proving and dependent types, and generating efficient executable code. This is clearly important if such high level languages are to be useful in practice, and even to demonstrate the usefulness and power of the language on anything other than small scale examples.

        
I think this paper can be accepted, though I have some small comments and suggestions for improvements:

        
The introductory example in section 2 provides a generally clear introduction to contextual objects, motivating the problem with a well-understood example. However, it would be nice to say more here about what the target of the compilation is (otherwise I'm not sure what you mean by using "simple names" here). You say: "The output is a fully annotated program using a representation close to the one presented by Cave and Pientka" - as well as the reference it would be very useful here to summarise what that representation is. There are a couple of instances of this, where some background is assumed, which would be good to explain in a couple of sentences in the early sections - e.g. it would also be useful to say what you mean by "Fresh-Style" earlier on.

        
Section 4 - maybe give the informal description of fresh binders earlier?

        
p6-7 On dependency erasure - "The compiler keeps the simple types as a way of sanity check" - is this always true? It isn't true in general for dependent types (consider, for example, a function which computes a simple type) and certainly not with more aggressive dependency erasure such as forcing of constructor arguments which is implemented in Agda and Idris, for example.

        
p9 It seems that the type system is strong enough to support some optimisations on pattern match compilation - such as Epigram's detagging, where the result of a case split on one value informs what another value should be.

        
In related work, you don't mention any other compilers for dependently typed languages which have to tackle similar problems, though you do mention program extraction for Coq. There is also MAlonzo, which translates Agda to Haskell, and Epic (Trends in Functional Programming), used by Epigram, Agda and Idris, which deals with naming though in a much more limited way than this paper.},
author = {Ferreira, Francisco and Monnier, Stefan and Pientka, Brigitte},
file = {:Users/edwin/Documents/Mendeley Desktop/Ferreira, Monnier, Pientka/Compiling Contextual Objects Bringing Higher-Order Abstract Syntax to Programmers/Ferreira, Monnier, Pientka - Compiling Contextual Objects Bringing Higher-Order Abstract Syntax to Programmers - 2012.pdf:pdf},
keywords = {compilation,contextual objects,pattern matching},
title = {{Compiling Contextual Objects Bringing Higher-Order Abstract Syntax to Programmers}},
year = {2012}
}
@misc{The2012b,
author = {Brooks, Fred},
doi = {10.1093/epirev/mxr031},
file = {:Users/edwin/Documents/Mendeley Desktop/Brooks/The Design of Design Chapter 1/Brooks - The Design of Design Chapter 1 - Unknown.pdf:pdf},
isbn = {9780321702081},
issn = {1478-6729},
pmid = {22215642},
title = {{The Design of Design Chapter 1}}
}
@book{peyton1987implementation,
author = {{Peyton Jones}, S.L.},
publisher = {Prentice-Hall, Inc.},
title = {{The implementation of functional programming languages (prentice-hall international series in computer science)}},
url = {http://dl.acm.org/citation.cfm?id=1096899},
year = {1987}
}
@article{Miller1992,
author = {Miller, Dale},
file = {:Users/edwin/Documents/Mendeley Desktop/Miller/Unification under a mixed prefix/Miller - Unification under a mixed prefix - 1992.pdf:pdf},
journal = {Journal of Symbolic Computation},
title = {{Unification under a mixed prefix}},
url = {http://www.sciencedirect.com/science/article/pii/074771719290011R},
year = {1992},
volume = {14},
pages = {321--358}
}
@inproceedings{Danielsson2010,
author = {Danielsson, Nils Anders},
booktitle = {International Conference on Functional Programming},
doi = {10.1145/1932681.1863585},
file = {:Users/edwin/Documents/Mendeley Desktop/Danielsson/Total parser combinators/Danielsson - Total parser combinators - 2010.pdf:pdf},
isbn = {978-1-60558-794-3},
issn = {03621340},
keywords = {dependent types,mixed induction and coinduction,parser combinators,productivity,termination},
month = sep,
number = {9},
pages = {285},
title = {{Total parser combinators}},
url = {http://dl.acm.org/citation.cfm?id=1932681.1863585},
volume = {45},
year = {2010}
}
@inproceedings{augustsson1999exercise,
author = {Augustsson, L. and Carlsson, M.},
booktitle = {In Workshop on Dependent Types in Programming, Gothenburg},
keywords = {Depe},
mendeley-tags = {Depe},
publisher = {Citeseer},
title = {{An exercise in dependent types: A well-typed interpreter}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.2895},
year = {1999}
}
@inproceedings{Sheard2005,
address = {New York, New York, USA},
author = {Sheard, Tim},
booktitle = {Proceedings of the 2005 ACM SIGPLAN workshop on Haskell - Haskell '05},
doi = {10.1145/1088348.1088356},
file = {:Users/edwin/Documents/Mendeley Desktop/Sheard/Putting curry-howard to work/Sheard - Putting curry-howard to work - 2005.pdf:pdf},
isbn = {159593071X},
keywords = {GADT,curry-howard isomorphism,extensional kind system,haskell,logic},
month = sep,
pages = {74--85},
publisher = {ACM Press},
title = {{Putting curry-howard to work}},
url = {http://dl.acm.org/citation.cfm?id=1088348.1088356},
year = {2005}
}
@phdthesis{McBride1999,
author = {McBride, Conor},
file = {:Users/edwin/Documents/Mendeley Desktop/McBride/Dependently typed functional programs and their proofs/McBride - Dependently typed functional programs and their proofs - 1999.pdf:pdf},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
school = {University of Edinburgh},
title = {{Dependently typed functional programs and their proofs}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.26.4785&rep=rep1&type=pdf},
year = {1999}
}
@article{The2012a,
author = {Bentley, Jon},
doi = {10.1093/geront/gns026},
file = {:Users/edwin/Documents/Mendeley Desktop/Bentley/Beautiful Code Chapter 3/Bentley - Beautiful Code Chapter 3 - 2012.pdf:pdf},
isbn = {9780596510046},
issn = {1758-5341},
month = dec,
number = {6},
pages = {NP},
pmid = {23150082},
title = {{Beautiful Code Chapter 3}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23150082},
volume = {52},
year = {2012}
}
@inproceedings{Fournet2011,
author = {Fournet, Cedric and Bhargavan, Karthikeyan and Gordon, Andrew D},
booktitle = {Foundations of security analysis and design {VI}},
file = {:Users/edwin/Documents/Mendeley Desktop/Fournet, Bhargavan, Gordon/Cryptographic verification by typing for a sample protocol implementation/Fournet, Bhargavan, Gordon - Cryptographic verification by typing for a sample protocol implementation - 2010.pdf:pdf},
title = {{Cryptographic verification by typing for a sample protocol implementation}},
url = {http://www.springerlink.com/index/V168041M46658R73.pdf},
year = {2010}
}
@inproceedings{chlipala2010ur,
author = {Chlipala, Adam},
booktitle = {ACM SIGPLAN Notices},
file = {:Users/edwin/Documents/Mendeley Desktop/Chlipala/Ur statically-typed metaprogramming with type-level record computation/Chlipala - Ur statically-typed metaprogramming with type-level record computation - 2010.pdf:pdf},
number = {6},
pages = {122--133},
publisher = {ACM},
title = {{Ur: statically-typed metaprogramming with type-level record computation}},
url = {http://dl.acm.org/citation.cfm?id=1806612},
volume = {45},
year = {2010}
}
@article{Fluet,
annote = {0,3

        
This paper gives a control flow analysis for polymorphic functional programs (specifically System F with recursion). Surprisingly (to me at least) this appears not to have been done before, with previous analyses targetting dynamically typed or simply typed languages, or handling polymorphism by explicitly eliminating it. It seems to be a worthwhile exercise: richer static type systems should give more information to support static analysis.

        
While I like what is achieved by this paper, I did find it rather hard going. The introduction feels laboured and then the paper covers a lot of detail (possibly too much) in quite a short space (though it still runs to 18 pages, two more than the limit!). I would suggest that the paper would be much improved, particularly to a non-expert reader, if it give one or more motivating examples in the introduction and showed how the analysis applied to these examples, when translated to ANF.
I think this would shorten the introduction and give a much better intuition for the rules.},
author = {Fluet, Matthew},
file = {:Users/edwin/Documents/Mendeley Desktop/Fluet/A Type- and Control-Flow Analysis for System F/Fluet - A Type- and Control-Flow Analysis for System F - Unknown.pdf:pdf},
pages = {1--18},
title = {{A Type- and Control-Flow Analysis for System F}}
}
@article{Vytiniotis2011,
author = {Vytiniotis, Dimitrios and {Peyton Jones}, Simon and Schrijvers, Tom and Sulzmann, Martin},
file = {:Users/edwin/Documents/Mendeley Desktop/Vytiniotis et al/textsc{OutsideIn}(X) Modular type inference with local assumptions/Vytiniotis et al. - textsc{OutsideIn}(X) Modular type inference with local assumptions - 2011.pdf:pdf;:Users/edwin/Documents/Mendeley Desktop/Vytiniotis et al/textsc{OutsideIn}(X) Modular type inference with local assumptions/Vytiniotis et al. - textsc{OutsideIn}(X) Modular type inference with local assumptions - 2011(2).pdf:pdf},
journal = {{Journal of Functional Programming}},
number = {4--5},
pages = {333----412},
title = {{\textsc{OutsideIn}(X) Modular type inference with local assumptions}},
url = {http://journals.cambridge.org/abstract_S0956796811000098},
volume = {21},
year = {2011}
}
@inproceedings{Gregoire2005,
author = {Gregoire, Benjamin and Mahboubi, Assia},
booktitle = {{Theorem Proving in Higher Order Logics (TPHOLS 2005)}},
file = {:Users/edwin/Documents/Mendeley Desktop/Gregoire, Mahboubi/Proving Equalities in a Commutative Ring Done Right in Coq/Gregoire, Mahboubi - Proving Equalities in a Commutative Ring Done Right in Coq - 2005.pdf:pdf},
pages = {98----113},
title = {{Proving Equalities in a Commutative Ring Done Right in Coq}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.61.3041},
year = {2005}
}
@book{Cryptography2012,
author = {Anderson, Ross},
doi = {10.1093/intimm/dxs023},
file = {:Users/edwin/Documents/Mendeley Desktop/Anderson/Security Engineering Chapter 5/Anderson - Security Engineering Chapter 5 - Unknown.pdf:pdf},
isbn = {9780470068526},
issn = {1460-2377},
number = {4},
pmid = {22451589},
title = {{Security Engineering Chapter 5}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/22451589},
volume = {24}
}
@article{Brady,
author = {Butenhof, David R.},
file = {:Users/edwin/Documents/Mendeley Desktop/Butenhof/Programming with POSIX Threads Chapter 8/Butenhof - Programming with POSIX Threads Chapter 8 - Unknown.pdf:pdf},
isbn = {0201633922},
title = {{Programming with POSIX Threads Chapter 8}}
}
@inproceedings{oury2008power,
author = {Oury, N. and Swierstra, W.},
booktitle = {International Conference on Functional Programming},
file = {:Users/edwin/Documents/Mendeley Desktop/Oury, Swierstra/The power of Pi/Oury, Swierstra - The power of Pi - 2008.pdf:pdf},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
number = {9},
pages = {39--50},
publisher = {ACM},
title = {{The power of Pi}},
url = {http://dl.acm.org/citation.cfm?id=1411213},
volume = {43},
year = {2008}
}
@article{McBride2004a,
abstract = {ABSTRACT Pattern matching has proved an extremely powerful and durable notion in functional programming. This paper contributes a new programming notation for type theory which elaborates the notion in various ways. First, as is by now quite well-known in the type theory community, definition by pattern matching becomes a more discriminating tool in the presence of dependent types, since it refines the explanation of types as well as values. This becomes all the more true in the presence of the rich class of datatypes known as inductive families (Dybjer, 1991). Secondly, as proposed by Peyton Jones (1997) for Haskell, and independently rediscovered by us, subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions by pattern matching, should rather be handled on the left. In simply-typed languages, this subsumes the trivial case of Boolean guards; in our setting it becomes yet more powerful. Thirdly, elementary pattern matching decompositions have a well-defined interface given by a dependent type; they correspond to the statement of an induction principle for the datatype. More general, user-definable decompositions may be defined which also have types of the same general form. Elementary pattern matching may therefore be recast in abstract form, with a semantics given by translation. Such abstract decompositions of data generalize Wadler&apos;s (1987) notion of &lsquo;view&rsquo;. The programmer wishing to introduce a new view of a type mathitT, and exploit it directly in pattern matching, may do so via a standard programming idiom. The type theorist, looking through the Curry&ndash;Howard lens, may see this as proving a theorem, one which establishes the validity of a new induction principle for mathitT. We develop enough syntax and semantics to account for this high-level style of programming in dependent type theory. We close with the development of a typechecker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is ipso facto a proof that typechecking is decidable.},
author = {McBride, Conor and McKinna, James},
doi = {10.1017/S0956796803004829},
file = {:Users/edwin/Documents/Mendeley Desktop/McBride, McKinna/The view from the left/McBride, McKinna - The view from the left - 2004.pdf:pdf},
issn = {09567968},
journal = {Journal of Functional Programming},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
number = {1},
pages = {69--111},
publisher = {Cambridge University Press},
title = {{The view from the left}},
url = {http://www.journals.cambridge.org/abstract_S0956796803004829},
volume = {14},
year = {2004}
}
@book{Cryptography2012a,
author = {Pfleeger, Charles P and Pfleeger, S. L.},
booktitle = {Nicotine & tobacco research : official journal of the Society for Research on Nicotine and Tobacco},
doi = {10.1093/ntr/nts035},
file = {:Users/edwin/Documents/Mendeley Desktop/Pfleeger, Pfleeger/Security in Computing Chapter 2/Pfleeger, Pfleeger - Security in Computing Chapter 2 - 2012.pdf:pdf},
isbn = {0132390779},
issn = {1469-994X},
month = oct,
number = {10},
pages = {NP},
pmid = {23012339},
title = {{Security in Computing Chapter 2}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23012339},
volume = {14},
year = {2012}
}
@phdthesis{Pretnar2010,
author = {Pretnar, Matija},
file = {:Users/edwin/Documents/Mendeley Desktop/Pretnar/The Logic and Handling of Algebraic Effects/Pretnar - The Logic and Handling of Algebraic Effects - 2010.pdf:pdf},
school = {University of Edinburgh},
title = {{The Logic and Handling of Algebraic Effects}},
year = {2010}
}
@inproceedings{Brady2010,
author = {Brady, Edwin and Hammond, Kevin},
booktitle = {Proceedings of the 15th ACM SIGPLAN international conference on Functional programming},
file = {:Users/edwin/Documents/Mendeley Desktop/Brady, Hammond/Scrapping your inefficient engine using partial evaluation to improve domain-specific language implementation/Brady, Hammond - Scrapping your inefficient engine using partial evaluation to improve domain-specific language implementation - 2010.pdf:pdf},
isbn = {9781605587943},
keywords = {Dependent Types,code generation gives,contrast,dependent types,efficient,harder,however,implementation,likely efficient,ness interpreter,partial evaluation,resulting implementation,un,verify its correctness},
mendeley-tags = {Dependent Types},
pages = {297--308},
publisher = {ACM},
title = {{Scrapping your inefficient engine: using partial evaluation to improve domain-specific language implementation}},
url = {http://portal.acm.org/citation.cfm?id=1863587},
year = {2010}
}
@misc{Danielsson2002,
author = {Danielsson, Nils Anders and Altenkirch, Thorsten},
file = {:Users/edwin/Documents/Mendeley Desktop/Danielsson, Altenkirch/Subtyping, Declaratively/Danielsson, Altenkirch - Subtyping, Declaratively - 2002.pdf:pdf},
title = {{Subtyping, Declaratively}},
year = {2002}
}
@book{Strings2012,
author = {Sedgewick, Robert and Wayne, Kevin},
booktitle = {Nicotine & tobacco research : official journal of the Society for Research on Nicotine and Tobacco},
doi = {10.1093/ntr/nts035},
file = {:Users/edwin/Documents/Mendeley Desktop/Sedgewick, Wayne/Algorithms Chapter 5/Sedgewick, Wayne - Algorithms Chapter 5 - 2012.pdf:pdf},
isbn = {9780132762571},
issn = {1469-994X},
month = oct,
number = {10},
pages = {NP},
pmid = {23012339},
title = {{Algorithms Chapter 5}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23012339},
volume = {14},
year = {2012}
}
@inproceedings{Augustsson1985,
address = {Berlin, Heidelberg},
author = {Augustsson, Lennart},
booktitle = {Functional Programming Languages and Computer Architecture},
doi = {10.1007/3-540-15975-4},
editor = {Jouannaud, Jean-Pierre},
isbn = {978-3-540-15975-9},
keywords = {Computer Science},
pages = {368----381},
publisher = {Springer Berlin Heidelberg},
series = {Lecture Notes in Computer Science},
title = {{Compiling Pattern Matching}},
url = {http://www.springerlink.com/content/y647423656557505/},
volume = {201},
year = {1985}
}
@misc{Abel1998,
author = {Abel, Andreas},
booktitle = {Language},
file = {:Users/edwin/Documents/Mendeley Desktop/Abel/foetus - Termination Checker for Simple Functional Programs/Abel - foetus - Termination Checker for Simple Functional Programs - 1998.pdf:pdf},
title = {{foetus - Termination Checker for Simple Functional Programs}},
year = {1998}
}
@article{Silkensen,
author = {Silkensen, Erik and Siek, Jeremy},
file = {:Users/edwin/Documents/Mendeley Desktop/Silkensen, Siek/Well-typed Islands Parse Faster/Silkensen, Siek - Well-typed Islands Parse Faster - Unknown.pdf:pdf},
title = {{Well-typed Islands Parse Faster}}
}
@misc{Svenningsson,
author = {Svenningsson, Josef and Axelsson, Emil},
booktitle = {Writing},
file = {:Users/edwin/Documents/Mendeley Desktop/Svenningsson, Axelsson/Combining Deep and Shallow Embedding for EDSL/Svenningsson, Axelsson - Combining Deep and Shallow Embedding for EDSL - Unknown.pdf:pdf},
title = {{Combining Deep and Shallow Embedding for EDSL}}
}
@misc{Bauer,
archivePrefix = {arXiv},
arxivId = {arXiv:1203.1539v1},
author = {Bauer, Andrej and Pretnar, Matija},
eprint = {arXiv:1203.1539v1},
file = {:Users/edwin/Documents/Mendeley Desktop/Bauer, Pretnar/Programming with Algebraic Effects and Handlers/Bauer, Pretnar - Programming with Algebraic Effects and Handlers - Unknown.pdf:pdf},
keywords = {()},
title = {{Programming with Algebraic Effects and Handlers}}
}
@misc{Krustev,
author = {Krustev, Dimitur},
booktitle = {Language},
file = {:Users/edwin/Documents/Mendeley Desktop/Krustev/Towards a Framework for Building Formally Verified Supercompilers in Coq/Krustev - Towards a Framework for Building Formally Verified Supercompilers in Coq - Unknown.pdf:pdf},
title = {{Towards a Framework for Building Formally Verified Supercompilers in Coq}}
}
@book{Graphs2012,
author = {Sedgewick, Robert and Wayne, Kevin},
booktitle = {The Gerontologist},
doi = {10.1093/geront/gns026},
file = {:Users/edwin/Documents/Mendeley Desktop/Sedgewick, Wayne/Algorithms Chapter 4/Sedgewick, Wayne - Algorithms Chapter 4 - 2012.pdf:pdf},
isbn = {9780132762571},
issn = {1758-5341},
month = dec,
number = {6},
pages = {NP},
pmid = {23150082},
title = {{Algorithms Chapter 4}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23150082},
volume = {52},
year = {2012}
}
@misc{Brady2012c,
author = {Brooks, Fred},
doi = {10.1093/epirev/mxr031},
file = {:Users/edwin/Documents/Mendeley Desktop/Brooks/The Design of Design Chapter 5/Brooks - The Design of Design Chapter 5 - Unknown.pdf:pdf},
isbn = {9780321702081},
issn = {1478-6729},
number = {1},
pages = {NP},
pmid = {22215642},
title = {{The Design of Design Chapter 5}},
volume = {34}
}
@inproceedings{coquand1986analysis,
author = {Coquand, T.},
booktitle = {{Proceedings of the First IEEE Symposium on Logic in Computer Science}},
file = {:Users/edwin/Documents/Mendeley Desktop/Coquand/An analysis of Girard's paradox/Coquand - An analysis of Girard's paradox - 1986.pdf:pdf},
pages = {227----246},
title = {{An analysis of Girard's paradox}},
url = {http://hal.inria.fr/docs/00/07/60/23/PDF/RR-0531.pdf},
year = {1986}
}
@book{Harper2012,
author = {Harper, Robert},
file = {:Users/edwin/Documents/Mendeley Desktop/Harper/Practical Foundations for Programming Languages/Harper - Practical Foundations for Programming Languages - 2012.pdf:pdf},
title = {{Practical Foundations for Programming Languages}},
year = {2012}
}
@misc{dagand2011transporting,
author = {Dagand, Pierre-Evariste and McBride, Conor},
file = {:Users/edwin/Documents/Mendeley Desktop/Dagand, McBride/Transporting Functions across Ornaments/Dagand, McBride - Transporting Functions across Ornaments - 2011.pdf:pdf},
title = {{Transporting Functions across Ornaments}},
url = {http://personal.cis.strath.ac.uk/$\sim$dagand/stuffs/paper-2011-patch/paper.pdf},
year = {2011}
}
@article{Abel2010,
abstract = {Sized types are a modular and theoretically well-understood tool for checking termination of recursive and productivity of corecursive definitions. The essential idea is to track structural descent and guardedness in the type system to make termination checking robust and suitable for strong abstractions like higher-order functions and polymorphism. To study the application of sized types to proof assistants and programming languages based on dependent type theory, we have implemented a core language, MiniAgda, with explicit handling of sizes. New considerations were necessary to soundly integrate sized types with dependencies and pattern matching, which was made possible by concepts such as inaccessible patterns and parametric function spaces. This paper provides an introduction to MiniAgda by example and informal explanations of the underlying principles.},
author = {Abel, Andreas},
file = {:Users/edwin/Documents/Mendeley Desktop/Abel/MiniAgda Integrating Sized and Dependent Types/Abel - MiniAgda Integrating Sized and Dependent Types - 2010.pdf:pdf},
journal = {EPTCS},
pages = {1--15},
title = {{MiniAgda: Integrating Sized and Dependent Types}},
url = {http://arxiv.org/abs/1012.4896},
volume = {43},
year = {2010}
}
@article{burrows1990,
author = {Burrows, Michael and Abadi, Martin and Needham, Roger},
file = {:Users/edwin/Documents/Mendeley Desktop/Burrows, Abadi, Needham/A logic of authentication/Burrows, Abadi, Needham - A logic of authentication - 1990.pdf:pdf},
journal = {ACM Transactions on Computer Systems},
pages = {18----36},
title = {{A logic of authentication}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.115.3569},
volume = {8},
year = {1990}
}
@article{loh2010tutorial,
author = {L\"{o}h, A. and McBride, C. and Swierstra, W.},
file = {:Users/edwin/Documents/Mendeley Desktop/L\"{o}h, McBride, Swierstra/A tutorial implementation of a dependently typed lambda calculus/L\"{o}h, McBride, Swierstra - A tutorial implementation of a dependently typed lambda calculus - 2010.pdf:pdf},
journal = {Fundamenta Informaticae},
number = {2},
pages = {177--207},
publisher = {IOS Press},
title = {{A tutorial implementation of a dependently typed lambda calculus}},
url = {http://iospress.metapress.com/index/976W4716TM79M6U8.pdf},
volume = {102},
year = {2010}
}
@article{mcbride2008functional,
author = {McBride, C. and Paterson, R.},
file = {:Users/edwin/Documents/Mendeley Desktop/McBride, Paterson/Functional pearl Applicative programming with effects/McBride, Paterson - Functional pearl Applicative programming with effects - 2008.pdf:pdf},
journal = {Journal of functional programming},
number = {1},
pages = {1--13},
publisher = {Cambridge Univ Press},
title = {{Functional pearl: Applicative programming with effects}},
url = {http://journals.cambridge.org/production/action/cjoGetFulltext?fulltextid=1457860},
volume = {18},
year = {2008}
}
@techreport{Cardelli1988,
author = {Cardelli, L},
file = {:Users/edwin/Documents/Mendeley Desktop/Cardelli/Phase distinctions in type theory/Cardelli - Phase distinctions in type theory - 1988.pdf:pdf},
title = {{Phase distinctions in type theory}},
year = {1988}
}
@misc{Abadi1997,
author = {Abadi, Martin and Gordon, Andrew D},
booktitle = {4TH ACM CONFERENCE ON COMPUTER AND COMMUNICATIONS SECURITY},
file = {:Users/edwin/Documents/Mendeley Desktop/Abadi, Gordon/A calculus for cryptographic protocols The spi calculus/Abadi, Gordon - A calculus for cryptographic protocols The spi calculus - 1997.pdf:pdf},
pages = {36 -- 47},
title = {{A calculus for cryptographic protocols: The spi calculus}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.49.2176},
year = {1997}
}
@article{Haskell2012a,
author = {Biancuzzi, F and Warden, S},
doi = {10.1093/epirev/mxr031},
file = {:Users/edwin/Documents/Mendeley Desktop/Biancuzzi, Warden/Masterminds of Programming Chapter 8/Biancuzzi, Warden - Masterminds of Programming Chapter 8 - Unknown.pdf:pdf},
isbn = {9780596801670},
issn = {1478-6729},
pmid = {22215642},
title = {{Masterminds of Programming Chapter 8}}
}
@inproceedings{madhavapeddy2010turning,
author = {Madhavapeddy, A. and Mortier, R. and Sohan, R. and Gazagnaire, T. and Hand, S. and Deegan, T. and McAuley, D. and Crowcroft, J.},
booktitle = {Proceedings of the 2nd USENIX conference on Hot topics in cloud computing},
file = {:Users/edwin/Documents/Mendeley Desktop/Madhavapeddy et al/Turning down the LAMP software specialisation for the cloud/Madhavapeddy et al. - Turning down the LAMP software specialisation for the cloud - 2010.pdf:pdf},
publisher = {USENIX Association},
title = {{Turning down the LAMP: software specialisation for the cloud}},
url = {http://dl.acm.org/citation.cfm?id=1863114},
year = {2010}
}
@misc{Braßel,
annote = {New compilation system for Curry, a Haskell like language with equational constraints, making it a functional logic language.

        
What is the contribution of this paper? i.e. what is new about the compiler? Seems to be efficient implementation of equational constraints.

        
Nice introduction to the language, easy for a Haskell programmer to follow, and nice explanation of how it works motivating the problem. But I find it hard to tell what in the paper is already known and what is a specific contribution.

        
Functional patterns look nice, if hard to implement. Related to views? Limitations?
Could these techniques improve (compile-time) unification in dependently typed languages?

        
Not many results. Encouraging, but only 7 of various forms isn't conclusive. },
author = {Bra\ss el, Bernd and Hanus, Michael and Peem\"{o}ller, Bj\"{o}rn and Reck, Fabian},
file = {:Users/edwin/Documents/Mendeley Desktop/Bra\ss el et al/Implementing Equational Constraints in a Functional Language/Bra\ss el et al. - Implementing Equational Constraints in a Functional Language - Unknown.pdf:pdf},
keywords = {func-,functional logic programming,implementation,unification},
title = {{Implementing Equational Constraints in a Functional Language}}
}
@inproceedings{Brady2003,
author = {Brady, Edwin and McBride, Conor and McKinna, James},
booktitle = {Types for Proofs and Programs {(TYPES 2003)}},
file = {:Users/edwin/Documents/Mendeley Desktop/Brady, McBride, McKinna/Inductive families need not store their indices/Brady, McBride, McKinna - Inductive families need not store their indices - 2003.pdf:pdf},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
title = {{Inductive families need not store their indices}},
year = {2003}
}
@book{An2012,
author = {Fowler, Martin},
booktitle = {Carcinogenesis},
doi = {10.1093/carcin/bgs054},
file = {:Users/edwin/Documents/Mendeley Desktop/Fowler/Domain Specific Languages Chapter 1/Fowler - Domain Specific Languages Chapter 1 - Unknown.pdf:pdf},
isbn = {9780132107549},
issn = {1460-2180},
number = {3},
pmid = {22383472},
title = {{Domain Specific Languages Chapter 1}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/22383472},
volume = {33}
}
@book{Choosing2012,
author = {Fowler, Martin},
booktitle = {Carcinogenesis},
doi = {10.1093/carcin/bgs054},
file = {:Users/edwin/Documents/Mendeley Desktop/Fowler/Domain Specific Languages Chapter 6/Fowler - Domain Specific Languages Chapter 6 - Unknown.pdf:pdf},
isbn = {9780132107549},
issn = {1460-2180},
number = {3},
pmid = {22383472},
title = {{Domain Specific Languages Chapter 6}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/22383472},
volume = {33}
}
@misc{altenkirch2008nσ,
author = {Altenkirch, T. and Oury, N.},
file = {:Users/edwin/Documents/Mendeley Desktop/Altenkirch, Oury/$Pi$$Sigma$ A Core Language for Dependently Typed Programming/Altenkirch, Oury - $Pi$$Sigma$ A Core Language for Dependently Typed Programming - 2008.pdf:pdf},
title = {{$\Pi$$\Sigma$: A Core Language for Dependently Typed Programming}},
url = {http://verse.aasemoon.com/images/6/6f/PiSigma.pdf},
year = {2008}
}
@misc{Silkensen2012,
annote = {This paper tackles an interesting problem, namely that of building DSLs independently which are nevertheless composable (at least as far as parsing goes). The claim is that the approach taken - using type based disambiguation - can combine the good features of internal and external DSLs - namely, that they become easier to implement, and have a nice syntax.

        
I found the paper interesting to read, the contribution worthwhile and the results convincing, though I have a few suggestions for preparing the paper for TFP submission, since it wouldn't be possible to accept it in its current form.

        
Perhaps most importantly, the draft submission is in the SIGPLAN format, which means you've used a lot more space than you have available. I find that 1 SIGPLAN page becomes at least 2 in Springer format because of font size and margins, so you'll need to think carefully about what you consider the most important contribution of the paper, how much detail you can go into, and how many examples to give. 
If it helps, I think you could reduce section 5 to just a short sketch of Typed Racket and there'd be enough of a contribution to justify a TFP paper (though of course I can't speak for other potential referees!)

        
I found the paper a bit difficult to read at first since I don't have a detailed understand of parsing algorithms, and I suspect I won't be alone in this among the TFP readership. It would be useful to say more in the introduction about island parsing, and what a chart parsing strategy is. An intuitive explanation of the various parsing algorithms you give formally (Example 2.3, say) would be very useful for this (possibly even more useful than the formal descriptions...).

        
Another advantage of internal DSLs that I didn't see mentioned explicitly in the paper is that many features of the host language - syntax, code generation, type checking - are available for free, but have to be implemented explicitly for an external DSL. Maybe this is part of what you mean by interoperability. There is more than parsing needed for this though.

        
A question on contribution 1: how realistic is it to assume that nonterminals are largely disjoint? I could imagine, say, function calls or arithmetic being part of multiple DSLs if not factored out. Or have I misunderstood what you mean?

        
Some modern languages with dependent types have systems for syntax extension, e.g. Agda has mixfix declarations, Idris has syntax rules, type-directed elaboration and overloaded variable bindings. I wonder, therefore, if your approach to parsing could be better integrated into this kind of language, where embedded verifiable DSLs seem to be an obvious application. The Typed Racket example suggests to me that this would be an interesting thing to explore.},
author = {Silkensen, Erik and Siek, Jeremy},
file = {:Users/edwin/Documents/Mendeley Desktop/Silkensen, Siek/Well-typed Islands Parse Faster/Silkensen, Siek - Well-typed Islands Parse Faster - 2012.pdf:pdf},
pages = {1--12},
title = {{Well-typed Islands Parse Faster}},
year = {2012}
}
@misc{The2012c,
author = {Robbins, A and Hannah, E and Lamb, L},
doi = {10.1093/epirev/mxr031},
file = {:Users/edwin/Documents/Mendeley Desktop/Robbins, Hannah, Lamb/Learning the vi and Vim Editors/Robbins, Hannah, Lamb - Learning the vi and Vim Editors - Unknown.pdf:pdf},
isbn = {9780596529833},
issn = {1478-6729},
pmid = {22215642},
title = {{Learning the vi and Vim Editors}}
}
@misc{idristutorial,
author = {Brady, Edwin},
file = {:Users/edwin/Documents/Mendeley Desktop/Brady/Programming in Idris a tutorial/Brady - Programming in Idris a tutorial - 2012.pdf:pdf},
title = {{Programming in Idris : a tutorial}},
url = {http://idris-lang.org/tutorial},
year = {2013}
}
@book{Simon2012,
author = {Seibel, Peter},
booktitle = {The Gerontologist},
doi = {10.1093/geront/gns026},
file = {:Users/edwin/Documents/Mendeley Desktop/Seibel/Coders at Work Chapter 7/Seibel - Coders at Work Chapter 7 - 2012.pdf:pdf},
isbn = {9781430219484},
issn = {1758-5341},
month = dec,
number = {6},
pages = {NP},
pmid = {23150082},
title = {{Coders at Work Chapter 7}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23150082},
volume = {52},
year = {2012}
}
@misc{TheMendeleySupportTeam2011,
abstract = {A quick introduction to Mendeley. Learn how Mendeley creates your personal digital library, how to organize and annotate documents, how to collaborate and share with colleagues, and how to generate citations and bibliographies.},
address = {London},
author = {{The Mendeley Support Team}},
booktitle = {Mendeley Desktop},
file = {:Users/edwin/Documents/Mendeley Desktop/The Mendeley Support Team/Getting Started with Mendeley/The Mendeley Support Team - Getting Started with Mendeley - 2011.pdf:pdf},
keywords = {Mendeley,how-to,user manual},
pages = {1--16},
publisher = {Mendeley Ltd.},
title = {{Getting Started with Mendeley}},
url = {http://www.mendeley.com},
year = {2011}
}
@book{Brady2012d,
author = {Seibel, Peter},
booktitle = {The Gerontologist},
doi = {10.1093/geront/gns026},
file = {:Users/edwin/Documents/Mendeley Desktop/Seibel/Coders at Work Chapter 6/Seibel - Coders at Work Chapter 6 - 2012.pdf:pdf},
isbn = {9781430219484},
issn = {1758-5341},
month = dec,
number = {6},
pages = {NP},
pmid = {23150082},
title = {{Coders at Work Chapter 6}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23150082},
volume = {52},
year = {2012}
}
@inproceedings{l,
author = {L\"{a}mmel, R. and Jones, S.P.},
booktitle = {ACM SIGPLAN Notices},
file = {:Users/edwin/Documents/Mendeley Desktop/L\"{a}mmel, Jones/Scrap your boilerplate a practical design pattern for generic programming/L\"{a}mmel, Jones - Scrap your boilerplate a practical design pattern for generic programming - 2003.pdf:pdf},
number = {3},
pages = {26--37},
publisher = {ACM},
title = {{Scrap your boilerplate: a practical design pattern for generic programming}},
url = {http://dl.acm.org/citation.cfm?id=640136.604179},
volume = {38},
year = {2003}
}
@phdthesis{Okasaki1996,
author = {Okasaki, Chris},
file = {:Users/edwin/Documents/Mendeley Desktop/Okasaki/Purely Functional Data Structures/Okasaki - Purely Functional Data Structures - 1996.pdf:pdf},
school = {Carnegie Mellon University},
title = {{Purely Functional Data Structures}},
year = {1996}
}
@inproceedings{McBride2004b,
author = {McBride, Conor and McKinna, James},
booktitle = {Haskell Workshop},
file = {:Users/edwin/Documents/Mendeley Desktop/McBride, McKinna/I am not a number I am a free variable/McBride, McKinna - I am not a number I am a free variable - 2004.pdf:pdf},
title = {{I am not a number : I am a free variable}},
year = {2004}
}
@inproceedings{Brady2005a,
author = {Brady, E and Hammond, K},
booktitle = {Implementation and Application of Functional \ldots},
file = {:Users/edwin/Documents/Mendeley Desktop/Brady, Hammond/A dependently typed framework for static analysis of program execution costs/Brady, Hammond - A dependently typed framework for static analysis of program execution costs - 2005.pdf:pdf},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
title = {{A dependently typed framework for static analysis of program execution costs}},
url = {http://www.springerlink.com/index/P446P2HH70107759.pdf},
year = {2005}
}
@misc{TMR13,
author = {Eidhof, Chris and Elkins, Derek and Hicks, Stephen},
file = {:Users/edwin/Documents/Mendeley Desktop/Eidhof, Elkins, Hicks/The Monad . Reader Issue 13/Eidhof, Elkins, Hicks - The Monad . Reader Issue 13 - 2009.pdf:pdf},
number = {13},
title = {{The Monad . Reader Issue 13}},
year = {2009}
}
@inproceedings{taha2004gentle,
author = {Taha, W.},
booktitle = {Domain-Specific Program Generation},
pages = {30--50},
publisher = {Springer},
title = {{A gentle introduction to multi-stage programming}},
url = {http://www.springerlink.com/index/JEMT0D8VYN5JB2L8.pdf},
year = {2004}
}
@article{Rose,
annote = {This paper describes a language, Jeeves, for describing privacy policies and ensuring that they are automatically enforced. It gives the semantics of Jeeves in terms of a translation to a target language $\lambda_J$ and shows how to implement the privacy rules in a monadic style in Haskell which captures the constraint propagation.

        
Capturing policy rules in this way is an interesting idea and the monadic definition of constraint propagation is natural, but unfortunately the paper itself only seems half-written. I found the website (https://sites.google.com/site/jeevesprogramming/) and the tutorial there much more enlightening! Perhaps relating the implementation to some more extensive examples would be helpful, illustrating how the Haskell code relates to Jeeves programs. This would be particularly valuable in sections 3 and 5, and there is plenty of space available for this.

        
The paper could use a thorough proof read and spell check. For example:

        
end of sec 1 - references for the report and web site would be useful here.
End of sec 2: privacy politics? This is the only place this phrase is used.

        
p2 etal => et al

        
"The program read" => "The program reads"
"Depending on what" => comma before this
"bottem" => "bottom"

        
p4 "Eventhough" => "Even though"
"The program body, consist" => "The program body consists"

        
"but without any substantial..." - there is a missing word here

        
The presentation of Sec 5 is untidy - for example a section heading at the end of the page and bad spacing between subsections.

        
Reference 1 is blank

        

      },
author = {Rose, Eva},
file = {:Users/edwin/Documents/Mendeley Desktop/Rose/Declarative implementation aspects of privacy policy effects/Rose - Declarative implementation aspects of privacy policy effects - Unknown.pdf:pdf},
keywords = {constraints,language design,mon-,privacy policy,semantics},
title = {{Declarative implementation aspects of privacy policy effects}}
}
@inproceedings{morris2006exploring,
author = {Morris, P. and Altenkirch, T. and McBride, C.},
booktitle = {Types for Proofs and Programs},
file = {:Users/edwin/Documents/Mendeley Desktop/Morris, Altenkirch, McBride/Exploring the regular tree types/Morris, Altenkirch, McBride - Exploring the regular tree types - 2006.pdf:pdf},
pages = {252--267},
publisher = {Springer},
title = {{Exploring the regular tree types}},
url = {http://www.springerlink.com/index/f9p1317716614834.pdf},
year = {2006}
}
@inproceedings{pj2006gadts,
author = {{Peyton Jones}, S. and Vytiniotis, D. and Weirich, S. and Washburn, G.},
booktitle = {{International Conference on Functional Programming} ({ICFP} '06)},
file = {:Users/edwin/Documents/Mendeley Desktop/Peyton Jones et al/Simple unification-based type inference for GADTs/Peyton Jones et al. - Simple unification-based type inference for GADTs - 2006.pdf:pdf},
number = {9},
pages = {50--61},
publisher = {ACM},
title = {{Simple unification-based type inference for GADTs}},
url = {http://dl.acm.org/citation.cfm?id=1159811},
volume = {41},
year = {2006}
}
@book{luo1994,
author = {Luo, Z.},
publisher = {Oxford University Press, Inc.},
title = {{Computation and reasoning: a type theory for computer science}},
url = {http://dl.acm.org/citation.cfm?id=SERIES9893.184757},
year = {1994}
}
@misc{Hancock,
author = {Hancock, Peter and Setzer, Anton},
file = {:Users/edwin/Documents/Mendeley Desktop/Hancock, Setzer/Interactive Programs in Dependent Type Theory/Hancock, Setzer - Interactive Programs in Dependent Type Theory - 2000(2).pdf:pdf},
keywords = {dependent types,functional programming,interac-,monadic i,o,reactive programming,refinement,repetition constructs,tion},
title = {{Interactive Programs in Dependent Type Theory}},
year = {2000}
}
@book{Chlipala2012,
author = {Chlipala, Adam},
file = {:Users/edwin/Documents/Mendeley Desktop/Chlipala/Certified Programming with Dependent Types/Chlipala - Certified Programming with Dependent Types - 2012.pdf:pdf},
title = {{Certified Programming with Dependent Types}},
year = {2012}
}
@article{Mandelbaum2007,
abstract = {Massive amounts of useful data are stored and processed in ad hoc formats for which common tools like parsers, printers, query engines and format converters are not readily available. In this paper, we explain the design and implementation of PADS/ML , a new language and system that facilitates the generation of data processing tools for ad hoc formats. The PADS/ML design includes features such as dependent, polymorphic and recursive datatypes, which allow programmers to describe the syntax and semantics of ad hoc data in a concise, easy-to-read notation. The PADS/ML implementation compiles these descriptions into ml structures and functors that include types for parsed data, functions for parsing and printing, and auxiliary support for user-specified, format-dependent and format-independent tool generation.},
author = {Mandelbaum, Yitzhak and Fisher, Kathleen and Walker, David and Fernandez, Mary and Gleyzer, Artem},
doi = {10.1145/1190215.1190231},
isbn = {1595935754},
issn = {03621340},
journal = {SIGPLAN Not},
number = {1},
pages = {77--83},
publisher = {ACM},
series = {POPL '07},
title = {{PADS/ML: a functional data description language}},
url = {http://doi.acm.org/10.1145/1190216.1190231},
volume = {42},
year = {2007}
}
@article{Nabais2008,
author = {Nabais, Davide},
file = {:Users/edwin/Documents/Mendeley Desktop/Nabais/DesCo a Web Based Information System for Descriptional Complexity of Formal Languages/Nabais - DesCo a Web Based Information System for Descriptional Complexity of Formal Languages - 2008.pdf:pdf},
journal = {Most},
pages = {1--5},
title = {{DesCo : a Web Based Information System for Descriptional Complexity of Formal Languages}},
year = {2008}
}
@book{Edition2012,
author = {Pfleeger, Charles P and Pfleeger, S. L.},
booktitle = {Nicotine & tobacco research : official journal of the Society for Research on Nicotine and Tobacco},
doi = {10.1093/ntr/nts035},
file = {:Users/edwin/Documents/Mendeley Desktop/Pfleeger, Pfleeger/Security in Computing Chapter 1/Pfleeger, Pfleeger - Security in Computing Chapter 1 - 2012.pdf:pdf},
isbn = {0132390779},
issn = {1469-994X},
month = oct,
number = {10},
pages = {NP},
pmid = {23012339},
title = {{Security in Computing Chapter 1}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23012339},
volume = {14},
year = {2012}
}
@book{Eap,
author = {Fall, Kevin R and Stevens, W. Richard},
file = {:Users/edwin/Documents/Mendeley Desktop/Fall, Stevens/TCPIP Illustrated Chapter 18/Fall, Stevens - TCPIP Illustrated Chapter 18 - Unknown.pdf:pdf},
isbn = {9780132808200},
title = {{TCP/IP Illustrated Chapter 18}}
}
@book{Fowler,
author = {Fowler, Martin},
booktitle = {Language},
file = {:Users/edwin/Documents/Mendeley Desktop/Fowler/Domain Specific Languages Chapter 2/Fowler - Domain Specific Languages Chapter 2 - Unknown.pdf:pdf},
isbn = {9780132107549},
title = {{Domain Specific Languages Chapter 2}}
}
@book{Brady2012e,
author = {Seibel, Peter},
booktitle = {The Gerontologist},
doi = {10.1093/geront/gns026},
file = {:Users/edwin/Documents/Mendeley Desktop/Seibel/Coders at Work Chapter 9/Seibel - Coders at Work Chapter 9 - 2012.pdf:pdf},
isbn = {9781430219484},
issn = {1758-5341},
month = dec,
number = {6},
pages = {NP},
pmid = {23150082},
title = {{Coders at Work Chapter 9}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23150082},
volume = {52},
year = {2012}
}
@article{Regular2012,
author = {Kernighan, Brian},
doi = {10.1093/geront/gns026},
file = {:Users/edwin/Documents/Mendeley Desktop/Kernighan/Beautiful Code Chapter 1/Kernighan - Beautiful Code Chapter 1 - 2012.pdf:pdf},
isbn = {9780596510046},
issn = {1758-5341},
month = dec,
number = {6},
pages = {NP},
pmid = {23150082},
title = {{Beautiful Code Chapter 1}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23150082},
volume = {52},
year = {2012}
}
@inproceedings{norell2009dependently,
author = {Norell, Ulf},
booktitle = {Advanced Functional Programming},
file = {:Users/edwin/Documents/Mendeley Desktop/Norell/Dependently typed programming in Agda/Norell - Dependently typed programming in Agda - 2009.pdf:pdf},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
pages = {230--266},
publisher = {Springer},
title = {{Dependently typed programming in Agda}},
url = {http://www.springerlink.com/index/8X0H38858233VN26.pdf},
year = {2009}
}
@misc{Interface2012a,
author = {Kreibich, Jay A.},
doi = {10.1093/epirev/mxr031},
file = {:Users/edwin/Documents/Mendeley Desktop/Kreibich/Using SQLite Chapter 7/Kreibich - Using SQLite Chapter 7 - Unknown.pdf:pdf},
isbn = {9781449394592},
issn = {1478-6729},
pmid = {22215642},
title = {{Using SQLite Chapter 7}}
}
@inproceedings{Augustsson1998,
abstract = {Cayenne is a Haskell-like language. The main difference between Haskell and Cayenne is that Cayenne has dependent types, i.e., the result type of a function may depend on the argument value , and types of record components (which can be types or values) may depend on other components. Cayenne also combines the syntactic categories for value expressions and type expressions; thus reducing the number of language concepts. Having dependent types and combined type and value expressions makes the language very powerful. It is powerful enough that a special module concept is unnecessary; ordinary records suffice. It is also powerful enough to encode predicate logic at the type level, allowing types to be used as specifications of programs. However, this power comes at a cost: type checking of Cayenne is undecidable. While this may appear to be a steep price to pay, it seems to work well in practice.},
author = {Augustsson, Lennart},
booktitle = {International Conference on Functional Programming},
doi = {10.1097/MEG.0b013e328342f213},
file = {:Users/edwin/Documents/Mendeley Desktop/Augustsson/Cayenne - a language with dependent types/Augustsson - Cayenne - a language with dependent types - 1998.pdf:pdf},
issn = {14735687},
keywords = {Depe,Dependent Types},
mendeley-tags = {Depe,Dependent Types},
number = {1},
pages = {239--250},
pmid = {21139473},
publisher = {ACM Press},
title = {{Cayenne - a language with dependent types}},
url = {http://www.cs.chalmers.se/$\sim$augustss/cayenne/paper.ps},
volume = {23},
year = {1998}
}
@article{OutsideIn,
author = {Vytiniotis, D and {Peyton Jones}, Simon and Shrijvers, Tom and Sulzmann, Martin},
file = {:Users/edwin/Documents/Mendeley Desktop/Vytiniotis et al/textsc{OutsideIn}(X) Modular type inference with local assumptions/Vytiniotis et al. - textsc{OutsideIn}(X) Modular type inference with local assumptions - 2011.pdf:pdf},
journal = {Journal of Functional Programming},
number = {4--5},
pages = {333----412},
title = {{OutsideIn (X) Modular type inference with local assumptions}},
url = {http://journals.cambridge.org/production/action/cjoGetFulltext?fulltextid=8274818},
volume = {21},
year = {2011}
}
@inproceedings{fisher2005pads,
author = {Fisher, K. and Gruber, R.},
booktitle = {ACM SIGPLAN Notices},
number = {6},
pages = {295--304},
publisher = {ACM},
title = {{PADS: a domain-specific language for processing ad hoc data}},
url = {http://dl.acm.org/citation.cfm?id=1065046},
volume = {40},
year = {2005}
}
@inproceedings{Levitation2010,
author = {Chapman, James and Dagand, Pierre-Evariste and McBride, Conor and Morris, Peter},
booktitle = {{15th ACM SIGPLAN International Conference on Functional programming (ICFP '10)}},
doi = {10.1145/1932681.1863547},
file = {:Users/edwin/Documents/Mendeley Desktop/Chapman et al/The gentle art of levitation/Chapman et al. - The gentle art of levitation - 2010.pdf:pdf},
isbn = {978-1-60558-794-3},
issn = {03621340},
keywords = {Dependent Types,data structure,metaprogramming,monads,proof assistants,type systems},
mendeley-tags = {Dependent Types},
month = sep,
number = {9},
title = {{The gentle art of levitation}},
url = {http://dl.acm.org/citation.cfm?id=1932681.1863547},
volume = {45},
year = {2010}
}
@book{While2012,
author = {Hunt, Andrew and Thomas, David},
booktitle = {Carcinogenesis},
doi = {10.1093/carcin/bgs054},
file = {:Users/edwin/Documents/Mendeley Desktop/Hunt, Thomas/The Pragmatic Programmer Chapter 6/Hunt, Thomas - The Pragmatic Programmer Chapter 6 - Unknown.pdf:pdf},
isbn = {020161622X},
issn = {1460-2180},
number = {3},
pmid = {22383472},
title = {{The Pragmatic Programmer Chapter 6}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/22383472},
volume = {33}
}
@article{Hughes1989,
abstract = {As software becomes more and more complex, it is more and more important to structure it well. Well-structured software is easy to write, easy to debug, and provides a collection of modules that can be re-used to reduce future programming costs. Conventional languages place conceptual limits on the way problems can be modularised. Functional languages push those limits back. In this paper we show that two features of functional languages in particular, higher-order functions and lazy evaluation, can contribute greatly to modularity. As examples, we manipulate lists and trees, program several numerical algorithms, and implement the alpha-beta heuristic (an algorithm from Artificial Intelligence used in game-playing programs). Since modularity is the key to successful programming, functional languages are vitally important to the real world.},
author = {Hughes, J},
chapter = {2},
doi = {10.1093/comjnl/32.2.98},
editor = {Turner, David A},
file = {:Users/edwin/Documents/Mendeley Desktop/Hughes/Why Functional Programming Matters/Hughes - Why Functional Programming Matters - 1989.pdf:pdf},
institution = {Programming Methodology Group, University of {G\"{o}teborg} and Chalmers Institute of Technology, Sweden},
isbn = {0201172364},
issn = {00104620},
journal = {The Computer Journal},
number = {2},
pages = {98--107},
publisher = {Br Computer Soc},
title = {{Why Functional Programming Matters}},
url = {http://comjnl.oupjournals.org/cgi/doi/10.1093/comjnl/32.2.98},
volume = {32},
year = {1989}
}
@inproceedings{Asperti2011,
author = {Asperti, Andrea and Ricciotti, Wilmer and Coen, Claudio Sacerdoti and Tassi, Enrico},
booktitle = {{Automated Deduction --- CADE-23}},
file = {:Users/edwin/Documents/Mendeley Desktop/Asperti et al/The Matita Interactive Theorem Prover/Asperti et al. - The Matita Interactive Theorem Prover - 2011.pdf:pdf},
pages = {64----69},
title = {{The Matita Interactive Theorem Prover}},
year = {2011}
}
@article{Brady2006a,
author = {Brady, E and Hammond, K},
file = {:Users/edwin/Documents/Mendeley Desktop/Brady, Hammond/A verified staged interpreter is a verified compiler/Brady, Hammond - A verified staged interpreter is a verified compiler - 2006.pdf:pdf},
journal = {\ldots  of the 5th international conference on  \ldots},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
title = {{A verified staged interpreter is a verified compiler}},
url = {http://portal.acm.org/citation.cfm?id=1173706.1173724},
year = {2006}
}
@article{Xi1998,
abstract = {We present a type-based approach to eliminating array bound checking and list tag checking by conservatively extending Standard ML with a restricted form of dependent types. This enables the programmer to capture more invariants through types while type-checking remains decidable in theory and can still be performed efficiently in practice. We illustrate our approach through concrete examples and present the result of our preliminary experiments which support support the feasibility and effectiveness of our approach.},
author = {Xi, Hongwei and Pfenning, Frank},
doi = {10.1145/277652.277732},
file = {:Users/edwin/Documents/Mendeley Desktop/Xi, Pfenning/Eliminating array bound checking through dependent types/Xi, Pfenning - Eliminating array bound checking through dependent types - 1998.pdf:pdf},
isbn = {0897919874},
issn = {03621340},
journal = {ACM Sigplan Notices},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
number = {5},
pages = {249--257},
publisher = {ACM},
series = {PLDI '98},
title = {{Eliminating array bound checking through dependent types}},
url = {http://portal.acm.org/citation.cfm?doid=277652.277732},
volume = {33},
year = {1998}
}
@inproceedings{Abel2013,
author = {Abel, Andreas and Pientka, Brigitte and Thibodeau, David and Setzer, Anton},
booktitle = {Principles of Programming Languages},
file = {:Users/edwin/Documents/Mendeley Desktop/Abel et al/Copatterns Programming Infinite Structures by Observations/Abel et al. - Copatterns Programming Infinite Structures by Observations - 2013.pdf:pdf},
isbn = {9781450318327},
keywords = {2008,by the graduiertenkol-,coinduction,elimination,functional programming,introduction,leg programm und modellanalyse,message passing,of the deutsche,pattern matching,puma,thibodeau acknowledges financial support,vs},
title = {{Copatterns: Programming Infinite Structures by Observations}},
year = {2013}
}
@misc{pollack1997believe,
author = {Pollack, R.},
file = {:Users/edwin/Documents/Mendeley Desktop/Pollack/How to believe a machine-checked proof/Pollack - How to believe a machine-checked proof - 1997.pdf:pdf},
title = {{How to believe a machine-checked proof}},
url = {http://books.google.co.uk/books?hl=en&amp;lr=&amp;id=pLnKggT_In4C&amp;oi=fnd&amp;pg=PA205&amp;dq=how+to+believe+a+machine+checked+proof&amp;ots=c2OI8krqqA&amp;sig=EF3QonGFVdOpYdKO1KmW6ljCkjY},
year = {1997}
}
@book{Searching2012,
author = {Sedgewick, Robert and Wayne, Kevin},
booktitle = {The Gerontologist},
doi = {10.1093/geront/gns026},
file = {:Users/edwin/Documents/Mendeley Desktop/Sedgewick, Wayne/Algorithms Chapter 3/Sedgewick, Wayne - Algorithms Chapter 3 - 2012.pdf:pdf},
isbn = {9780132762571},
issn = {1758-5341},
month = dec,
number = {6},
pages = {NP},
pmid = {23150082},
title = {{Algorithms Chapter 3}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23150082},
volume = {52},
year = {2012}
}
@book{Philosophy2012,
author = {Hunt, Andrew and Thomas, David},
booktitle = {Carcinogenesis},
doi = {10.1093/carcin/bgs054},
file = {:Users/edwin/Documents/Mendeley Desktop/Hunt, Thomas/The Pragmatic Programmer Chapter 1/Hunt, Thomas - The Pragmatic Programmer Chapter 1 - Unknown.pdf:pdf},
isbn = {020161622X},
issn = {1460-2180},
number = {3},
pmid = {22383472},
title = {{The Pragmatic Programmer Chapter 1}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/22383472},
volume = {33}
}
@article{Servers,
author = {Totty, Brian and Gourley, David},
file = {:Users/edwin/Documents/Mendeley Desktop/Totty, Gourley/HTTP The Definitive Guide Chapter 5/Totty, Gourley - HTTP The Definitive Guide Chapter 5 - Unknown.pdf:pdf},
isbn = {1565925092},
title = {{HTTP: The Definitive Guide Chapter 5}}
}
@article{Bird2012a,
annote = {This new version of the paper is, I think, very clear and an entertaining read. It presents a neat example of program calculation and reasoning with each step in the calculation explained precisely - indeed the interesting thing to me is the calculation, rather than the problem itself, and it is nice that this works for an algorithm which requires in-place update (even if it does involve pretending // is in-place!).

        
I'm not totally convinced about the condition of the algorithm being "discovered in a disciplined manner" since many of the steps in the calculation required some insight, but others will disagree and I don't think it really matters for the main point of this paper in any case - the point is the calculational development, which is sufficiently detailed that a careful reader should be able to develop that insight, with practice. I would recommend this paper for acceptance in its current form. },
author = {Bird, Richard S},
file = {:Users/edwin/Documents/Mendeley Desktop/Bird/An in-situ algorithm for expanding a graph/Bird - An in-situ algorithm for expanding a graph - 2012.pdf:pdf},
keywords = {a href,journal of functional programming},
title = {{An in-situ algorithm for expanding a graph}},
year = {2012}
}
@inproceedings{Sculthorpe2009,
author = {Sculthorpe, Neil and Nilsson, Henrik},
booktitle = {International Conference on Functional Programming ({ICFP} '09)},
file = {:Users/edwin/Documents/Mendeley Desktop/Sculthorpe, Nilsson/Safe functional reactive programming through dependent types/Sculthorpe, Nilsson - Safe functional reactive programming through dependent types - 2009.pdf:pdf;:Users/edwin/Documents/Mendeley Desktop/Sculthorpe, Nilsson/Safe functional reactive programming through dependent types/Sculthorpe, Nilsson - Safe functional reactive programming through dependent types - 2009(2).pdf:pdf},
title = {{Safe functional reactive programming through dependent types}},
url = {http://dl.acm.org/citation.cfm?id=1596558},
year = {2009}
}
@article{landin1966next,
author = {Landin, P.J.},
file = {:Users/edwin/Documents/Mendeley Desktop/Landin/The next 700 programming languages/Landin - The next 700 programming languages - 1966.pdf:pdf},
journal = {Communications of the ACM},
number = {3},
pages = {157--166},
publisher = {ACM},
title = {{The next 700 programming languages}},
url = {http://dl.acm.org/citation.cfm?id=365257 )},
volume = {9},
year = {1966}
}
@inproceedings{Delahaye2000,
author = {Delahaye, D},
booktitle = {Logic for Programming and Automated Reasoning ({LPAR})},
file = {:Users/edwin/Documents/Mendeley Desktop/Delahaye/A tactic language for the system Coq/Delahaye - A tactic language for the system Coq - 2000.pdf:pdf;:Users/edwin/Documents/Mendeley Desktop/Delahaye/A tactic language for the system Coq/Delahaye - A tactic language for the system Coq - 2000(2).pdf:pdf},
pages = {85----95},
publisher = {Springer},
title = {{A tactic language for the system Coq}},
url = {http://www.springerlink.com/index/EFQAH8J88K42VN8T.pdf},
year = {2000}
}
@book{Messages,
author = {Totty, Brian and Gourley, David},
file = {:Users/edwin/Documents/Mendeley Desktop/Totty, Gourley/HTTP The Definitive Guide Chapter 3/Totty, Gourley - HTTP The Definitive Guide Chapter 3 - Unknown.pdf:pdf},
isbn = {1565925092},
title = {{HTTP: The Definitive Guide Chapter 3}}
}
@article{Asperti,
author = {Asperti, Andrea and Ricciotti, Wilmer and Coen, Claudio Sacerdoti and Tassi, Enrico},
doi = {10.2168/LMCS-},
file = {:Users/edwin/Documents/Mendeley Desktop/Asperti et al/A bi-directional refinement algorithm for the calculus of (co)inductive constructions/Asperti et al. - A bi-directional refinement algorithm for the calculus of (co)inductive constructions - 2012.pdf:pdf},
journal = {{Logical Methods in Computer Science}},
keywords = {and phrases,calculus of inductive construc-,interactive theorem prover,refiner,type inference},
pages = {1----49},
title = {{A bi-directional refinement algorithm for the calculus of (co)inductive constructions}},
volume = {8},
year = {2012}
}
@inproceedings{Altenkirch2010,
abstract = {The recent success of languages like Agda and Coq demonstrates the potential of using dependent types for programming. These systems rely on many high-level features like datatype definitions, pattern matching and implicit arguments to facilitate the use of the languages. However, these features complicate the metatheoretical study and are a potential source of bugs. To address these issues we introduce $\Pi$$\Sigma$, a dependently typed core language. It is small enough for metatheoretical study and the type checker is small enough to be formally verified. In this language there is only one mechanism for recursionused for types, functions and infinite objectsand an explicit mechanism to control unfolding, based on lifted types. Furthermore structural equality is used consistently for values and types; this is achieved by a new notion of $\alpha$-equality for recursive definitions. We show, by translating several high-level constructions, that $\Pi$$\Sigma$ is suitable as a core language for dependently typed programming.},
author = {Altenkirch, Thorsten and Danielsson, Nils Anders and L\"{o}h, Andres and Oury, Nicolas},
booktitle = {{FLOPS 2010}},
doi = {10.1007/978-3-642-12251-4_5},
editor = {Blume, Matthias and Kobayashi, Naoki and Vidal, Germ\'{a}n},
file = {:Users/edwin/Documents/Mendeley Desktop/Altenkirch et al/Dependent Types without the Sugar/Altenkirch et al. - Dependent Types without the Sugar - 2010.pdf:pdf},
isbn = {9783642122507},
pages = {40----55},
publisher = {Springer Berlin Heidelberg},
series = {Lecture Notes in Computer Science},
title = {{Dependent Types without the Sugar}},
url = {http://www.springerlink.com/index/91W712G2806R575H.pdf},
year = {2010}
}
@misc{Gobi2010,
author = {Gobi, Attila and Shkaravska, Olha and {Van Eekelen}, Marko},
booktitle = {Syntax},
file = {:Users/edwin/Documents/Mendeley Desktop/Gobi, Shkaravska, Van Eekelen/Higher-Order Size Checking Without Subtyping/Gobi, Shkaravska, Van Eekelen - Higher-Order Size Checking Without Subtyping - 2010.pdf:pdf},
number = {100039},
title = {{Higher-Order Size Checking Without Subtyping}},
year = {2010}
}
@book{Context2012,
author = {Sedgewick, Robert and Wayne, Kevin},
booktitle = {The Gerontologist},
doi = {10.1093/geront/gns026},
file = {:Users/edwin/Documents/Mendeley Desktop/Sedgewick, Wayne/Algorithms Chapter 6/Sedgewick, Wayne - Algorithms Chapter 6 - 2012.pdf:pdf},
isbn = {9780132762571},
issn = {1758-5341},
month = dec,
number = {6},
pages = {NP},
pmid = {23150082},
title = {{Algorithms Chapter 6}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23150082},
volume = {52},
year = {2012}
}
@misc{Protocols2012a,
author = {Anderson, Ross},
doi = {10.1093/epirev/mxr031},
file = {:Users/edwin/Documents/Mendeley Desktop/Anderson/Security Engineering Chapter 3/Anderson - Security Engineering Chapter 3 - Unknown.pdf:pdf},
isbn = {9780470068526},
issn = {1478-6729},
pmid = {22215642},
title = {{Security Engineering Chapter 3}}
}
@inproceedings{Visser2008,
author = {Visser, E},
booktitle = {Generative and Transformational Techniques in Software Engineering},
title = {{WebDSL: A case study in domain-specific language engineering}},
url = {http://www.springerlink.com/index/A3213003X6268032.pdf},
year = {2008}
}
@inproceedings{gibbons2011modularising,
author = {Gibbons, J. and Ko, H.S. and Others},
file = {:Users/edwin/Documents/Mendeley Desktop/Ko, Gibbons/Modularising inductive families/Ko, Gibbons - Modularising inductive families - 2011.pdf:pdf},
title = {{Modularising inductive families}},
url = {http://www.cs.ox.ac.uk/publications/publication5008-abstract.html},
year = {2011}
}
@book{Synchronization2012,
author = {Butenhof, David R.},
booktitle = {Nicotine & tobacco research : official journal of the Society for Research on Nicotine and Tobacco},
doi = {10.1093/ntr/nts035},
file = {:Users/edwin/Documents/Mendeley Desktop/Butenhof/Programming with POSIX Threads Chapter 3/Butenhof - Programming with POSIX Threads Chapter 3 - Unknown.pdf:pdf},
isbn = {0201633922},
issn = {1469-994X},
number = {10},
pmid = {23012339},
title = {{Programming with POSIX Threads Chapter 3}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23012339},
volume = {14}
}
@article{Pl,
annote = {-2, 3

        
This paper gives a type inference algorithm for Java extended with lambdas, extending earlier work on type inference for a small functional language with subtyping. It is interesting to see how this could work, and I'm sure this would be a welcome addition to Java. However, I didn't find the paper very well organised or presented so it was difficult to get very much from it. There is too much unnecessary detail (such as fragments of the parser or complete sets of coercions and substitutions) and not enough useful context such as syntax of Java_lambda with its typing rules.

        
If there is an implementation, it would also be good to give a url to download it so that the reader can try out some of the ideas given in the paper, and try to reproduce your results!

        
Other comments:

        
p1 The opening sentences don't seem to make sense on their own. It would be useful to know what your language in [7] is.

        
There are several typos which suggest that the paper could use a proof read and spell check. For example:
p2 "The improvement is that, that" => remove a "that"
"not necessary" => "not necessarily"
"can also consists" => "can also consist"
"remainig" => "remaining"

        
p3 What does "The concrete syntax [...] is oriented at [3]" mean? Is the syntax defined in this reference? It would be better to give it explicitly to make the paper more self contained.

        
p4 Is there some reason that you use tuples in the representation of classes, functions and expressions?

        
p9 "Decomposition: ..." I don't understand this sentence.

        
p10 "corecions" => "coercions" (several times)
also "coersions" => "coercions"

        
p14 (and other places similarly) I don't think it helps much to give the full set of substitutions here. A representative selection at most should be fine.

        

      },
author = {Pl\"{u}micke, Martin},
file = {:Users/edwin/Documents/Mendeley Desktop/Pl{u}micke/Functional implementation of well-typings in/Pl{u}micke - Functional implementation of well-typings in - Unknown.pdf:pdf},
title = {{Functional implementation of well-typings in}}
}
@article{gordon2003authenticity,
author = {Gordon, A.D. and Jeffrey, A.},
file = {:Users/edwin/Documents/Mendeley Desktop/Gordon, Jeffrey/Authenticity by typing for security protocols/Gordon, Jeffrey - Authenticity by typing for security protocols - 2003.pdf:pdf},
journal = {Journal of computer security},
number = {4},
pages = {451--520},
publisher = {IOS Press},
title = {{Authenticity by typing for security protocols}},
url = {http://iospress.metapress.com/index/BHQQUFRA1C7W8TLY.pdf},
volume = {11},
year = {2003}
}
@book{Approach2012,
author = {Hunt, Andrew and Thomas, David},
booktitle = {Carcinogenesis},
doi = {10.1093/carcin/bgs054},
file = {:Users/edwin/Documents/Mendeley Desktop/Hunt, Thomas/The Pragmatic Programmer Chapter 2/Hunt, Thomas - The Pragmatic Programmer Chapter 2 - Unknown.pdf:pdf},
isbn = {020161622X},
issn = {1460-2180},
number = {3},
pmid = {22383472},
title = {{The Pragmatic Programmer Chapter 2}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/22383472},
volume = {33}
}
@inproceedings{barras2008implicit,
author = {Barras, B. and Bernardo, B.},
booktitle = {Foundations of Software Science and Computational Structures},
file = {:Users/edwin/Documents/Mendeley Desktop/Barras, Bernardo/The implicit calculus of constructions as a programming language with dependent types/Barras, Bernardo - The implicit calculus of constructions as a programming language with dependent types - 2008.pdf:pdf},
pages = {365--379},
publisher = {Springer},
title = {{The implicit calculus of constructions as a programming language with dependent types}},
url = {http://www.springerlink.com/index/m84h82904546l265.pdf},
year = {2008}
}
@article{Zanasi,
author = {Zanasi, Fabio},
file = {:Users/edwin/Documents/Mendeley Desktop/Zanasi/On the Expressive Power of MSO and WMSO on Trees of Arbitrary Degree ( Extended abstract )/Zanasi - On the Expressive Power of MSO and WMSO on Trees of Arbitrary Degree ( Extended abstract ) - Unknown.pdf:pdf},
pages = {1--6},
title = {{On the Expressive Power of MSO and WMSO on Trees of Arbitrary Degree ( Extended abstract )}}
}
@article{Thiemann,
annote = {1, 4

        
This paper is a case study in dependently typed programming, investigating how an existing Haskell library (Accelerate) could benefit from dependent types by implementing a version of the library in Agda. The Haskell version is a generative library, meaning that programs are constructed as Haskell ADTs, then compiled to code which will run on a GPU. The authos observe that type correctness of Accelerate programs is checked statically, as far as possible, by using advanced features of the Haskell type system such as GADTs, and hypothesise that a language with a stronger type system such as Agda would increase the static guarantees which are expressible.

        
This is an interesting question, well worth asking, and the paper presents mixed results. The presentation of the Agda version is clear, and the relationship with the Haskell version is easy to see. However, some properties which one might hope to express turn out to be difficult in the current form. One conclusion I would draw from this is that to use dependent types well involves more than simply annotating an existing program.  The difficulties with filter and fold in particular show that care must be taken to preserve information required for checking later.

        
I wonder if the work has become too constrained by porting directly from the Haskell implementation. Perhaps a question to ask in future work would be - what would a dependently typed API to GPUs look like? What properties do we want to capture, and how can we do so with minimal work for the programmer?

        
Nevertheless, I enjoyed reading the paper and I think this is a good first step towards data parallel programming with dependent types.

        
Minor comments:

        
p3 Given that proceedings are in black and white, maybe it'd be more distinctive to put the Haskell code in a box rather than just a vertical bar?

        
p8 It would be useful to see the type of the zipWith function which corresponds to the Haskell version, if not the implementation (which I suspect is a little tricky).

        
p9 Probably not relevant to this paper, but this comment about properties of floating point arithmetic makes me wonder if it'd be possible to represent floating point error bounds in the type to recover these properties. 

        
p10 Another alternative for the type of filter could be a type level function to calculate the length. However, this would probably make proofs even harder. I think this is evidence that dependently typed programming is more than Haskell plus extra type annotations!

        
p14 "We have build" => "We have built"},
author = {Thiemann, Peter and Chakravarty, Manuel M T},
file = {:Users/edwin/Documents/Mendeley Desktop/Thiemann, Chakravarty/Agda Meets Accelerate/Thiemann, Chakravarty - Agda Meets Accelerate - Unknown.pdf:pdf},
keywords = {data parallelism,programming with dependent types},
pages = {1--16},
title = {{Agda Meets Accelerate}}
}
@inproceedings{Delahaye,
author = {Delahaye, David},
booktitle = {Proceedings of Logic for Programming and Automated Reasoning ({LPAR})},
file = {:Users/edwin/Documents/Mendeley Desktop/Delahaye/A Tactic Language for the System Coq/Delahaye - A Tactic Language for the System Coq - 2000(3).pdf:pdf},
title = {{A Tactic Language for the System Coq}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.66.9062},
year = {2000}
}
@inproceedings{atkey2009unembedding,
author = {Atkey, R. and Lindley, S. and Yallop, J.},
booktitle = {Proceedings of the 2nd ACM SIGPLAN symposium on Haskell},
pages = {37--48},
publisher = {ACM},
title = {{Unembedding domain-specific languages}},
url = {http://dl.acm.org/citation.cfm?id=1596644},
year = {2009}
}
@inproceedings{ko2011modularising,
author = {Ko, H.S. and Gibbons, J.},
booktitle = {Proceedings of the seventh ACM SIGPLAN workshop on Generic programming},
file = {:Users/edwin/Documents/Mendeley Desktop/Ko, Gibbons/Modularising inductive families/Ko, Gibbons - Modularising inductive families - 2011.pdf:pdf},
pages = {13--24},
publisher = {ACM},
title = {{Modularising inductive families}},
url = {http://www.cs.ox.ac.uk/publications/publication5008-abstract.html http://dl.acm.org/citation.cfm?id=2036921},
year = {2011}
}
@article{Chapman2005epigram,
author = {Chapman, James and Altenkirch, Thorsten and McBride, Conor},
file = {:Users/edwin/Documents/Mendeley Desktop/Chapman, Altenkirch, McBride/Epigram Reloaded A Standalone Typechecker for {ETT}/Chapman, Altenkirch, McBride - Epigram Reloaded A Standalone Typechecker for {ETT} - 2005.pdf:pdf},
journal = {Trends in Functional Programming},
publisher = {Intellect Books},
title = {{Epigram Reloaded: A Standalone Typechecker for {ETT}}},
url = {http://books.google.co.uk/books?hl=en&amp;lr=&amp;id=p0yV1sHLubcC&amp;oi=fnd&amp;pg=PA79&amp;dq=epigram+reloaded&amp;ots=x50ou0VMsm&amp;sig=7TjAGohIatNLTWsHcuNcK5hEGGY},
year = {2005}
}
@article{Hutton,
author = {Hutton, Graham and Fulger, Diana},
file = {:Users/edwin/Documents/Mendeley Desktop/Hutton, Fulger/Reasoning About Effects Seeing the Wood Through the Trees/Hutton, Fulger - Reasoning About Effects Seeing the Wood Through the Trees - Unknown.pdf:pdf},
title = {{Reasoning About Effects : Seeing the Wood Through the Trees}}
}
@article{dybjer1994inductive,
author = {Dybjer, P.},
journal = {Formal aspects of computing},
number = {4},
pages = {440--465},
publisher = {Springer},
title = {{Inductive families}},
url = {http://www.springerlink.com/index/J17824H467X6J288.pdf},
volume = {6},
year = {1994}
}
@misc{TheMendeleySupportTeam2011a,
abstract = {A quick introduction to Mendeley. Learn how Mendeley creates your personal digital library, how to organize and annotate documents, how to collaborate and share with colleagues, and how to generate citations and bibliographies.},
address = {London},
author = {{The Mendeley Support Team}},
booktitle = {Mendeley Desktop},
file = {:Users/edwin/Documents/Mendeley Desktop/The Mendeley Support Team/Getting Started with Mendeley/The Mendeley Support Team - Getting Started with Mendeley - 2011.pdf:pdf},
keywords = {Mendeley,how-to,user manual},
pages = {1--16},
publisher = {Mendeley Ltd.},
title = {{Getting Started with Mendeley}},
url = {http://www.mendeley.com},
year = {2011}
}
@misc{Brady2012b,
author = {Brooks, Fred},
doi = {10.1093/epirev/mxr031},
file = {:Users/edwin/Documents/Mendeley Desktop/Brooks/The Design of Design Chapter 2/Brooks - The Design of Design Chapter 2 - Unknown.pdf:pdf},
isbn = {9780321702081},
issn = {1478-6729},
pmid = {22215642},
title = {{The Design of Design Chapter 2}}
}
@misc{Bove2008,
abstract = {In these lecture notes we give an introduction to functional programming with dependent types. We use the dependently typed programming language Agda which is based on ideas in Martin-L\"{o}f type theory and Martin-L\"{o}fs logical framework. We begin by showing how to do simply typed functional programming, and discuss the differences between Agdas type system and the Hindley-Milner type system, which underlies mainstream typed functional programming languages like Haskell and ML. We then show how to employ dependent types for programming with functional data structures such as vectors and binary search trees. We go on to explain the Curry-Howard identification of propositions and types, and how it makes Agda not only a programming language but also a programming logic. According to Curry-Howard, we also identify programs and proofs, something which is possible only by requiring that all program terminate. However, we show in the final section a method for encoding general and possibly partial recursive functions as total functions using dependent types.},
author = {Bove, Ana and Dybjer, Peter},
booktitle = {Notes},
doi = {10.1007/978-3-642-03153-3_2},
file = {:Users/edwin/Documents/Mendeley Desktop/Bove, Dybjer/Dependent Types at Work/Bove, Dybjer - Dependent Types at Work - 2008.pdf:pdf},
number = {February},
pages = {57--99},
publisher = {Springer},
title = {{Dependent Types at Work}},
url = {http://www.springerlink.com/index/1039q8qk71257677.pdf},
volume = {5520},
year = {2008}
}
@article{In2012,
author = {Gulhati, Ashish},
doi = {10.1093/geront/gns026},
file = {:Users/edwin/Documents/Mendeley Desktop/Gulhati/Beautiful Code Chapter 11/Gulhati - Beautiful Code Chapter 11 - 2012.pdf:pdf},
isbn = {9780596510046},
issn = {1758-5341},
month = dec,
number = {6},
pages = {NP},
pmid = {23150082},
title = {{Beautiful Code Chapter 11}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23150082},
volume = {52},
year = {2012}
}
@article{McBride2002,
author = {McBride, C},
file = {:Users/edwin/Documents/Mendeley Desktop/McBride/Elimination with a Motive/McBride - Elimination with a Motive - 2000.pdf:pdf},
journal = {Types for proofs and programs ({TYPES 2000})},
title = {{Elimination with a Motive}},
url = {http://www.springerlink.com/index/vbpg19305t46f6dm.pdf},
year = {2000}
}
@inproceedings{lempsink2009type,
author = {Lempsink, E. and Leather, S. and L\"{o}h, A.},
booktitle = {Proceedings of the 2009 ACM SIGPLAN workshop on Generic programming},
file = {:Users/edwin/Documents/Mendeley Desktop/Lempsink, Leather, L\"{o}h/Type-safe diff for families of datatypes/Lempsink, Leather, L\"{o}h - Type-safe diff for families of datatypes - 2009.pdf:pdf},
pages = {61--72},
publisher = {ACM},
title = {{Type-safe diff for families of datatypes}},
url = {http://dl.acm.org/citation.cfm?id=1596624},
year = {2009}
}
@inproceedings{Brady2011a,
address = {New York, New York, USA},
author = {Brady, Edwin},
booktitle = {{Proceedings of the 5th {ACM} workshop on Programming Languages Meets Program Verification - PLPV '11}},
doi = {10.1145/1929529.1929536},
file = {:Users/edwin/Documents/Mendeley Desktop/Brady/Idris --- Systems Programming Meets Full Dependent Types/Brady - Idris --- Systems Programming Meets Full Dependent Types - 2011.pdf:pdf},
isbn = {9781450304870},
keywords = {Dependent Types,data description,dependent types},
mendeley-tags = {Dependent Types},
month = jan,
publisher = {ACM Press},
title = {{Idris --- Systems Programming Meets Full Dependent Types}},
url = {http://dl.acm.org/citation.cfm?id=1929529.1929536},
year = {2011}
}
@misc{altenkirch2005dependent,
author = {Altenkirch, T. and McBride, C. and McKinna, J.},
booktitle = {Manuscript, available online},
file = {:Users/edwin/Documents/Mendeley Desktop/Altenkirch, McBride, McKinna/Why dependent types matter/Altenkirch, McBride, McKinna - Why dependent types matter - 2005.pdf:pdf},
title = {{Why dependent types matter}},
url = {http://www.cs.nott.ac.uk/$\sim$txa/talks/splst11.pdf},
year = {2005}
}
@misc{Nodes2012a,
author = {Brooks, Fred},
doi = {10.1093/epirev/mxr031},
file = {:Users/edwin/Documents/Mendeley Desktop/Brooks/The Design of Design Chapter 3/Brooks - The Design of Design Chapter 3 - Unknown.pdf:pdf},
isbn = {9780321702081},
issn = {1478-6729},
pmid = {22215642},
title = {{The Design of Design Chapter 3}}
}
@article{danielsson2011parsing,
author = {Danielsson, N. and Norell, U.},
journal = {Implementation and Application of Functional Languages},
pages = {80--99},
publisher = {Springer},
title = {{Parsing mixfix operators}},
url = {http://www.springerlink.com/index/386243257W504252.pdf},
year = {2011}
}
@book{Bird2010,
author = {Bird, Richard},
file = {:Users/edwin/Documents/Mendeley Desktop/Bird/Pearls of Functional Algorithm Design/Bird - Pearls of Functional Algorithm Design - 2010.pdf:pdf},
isbn = {9780521513388},
title = {{Pearls of Functional Algorithm Design}},
year = {2010}
}
@article{Jones1999,
abstract = {Haskell benefits from a sophisticated type system, but implementors, programmers, and researchers suffer because it has no formal description. To remedy this shortcoming, we present a Haskell program that implements a Haskell typechecker, thus providing a mathematically rigorous specification in a notation that is familiar to Haskell users. We expect this program to fill a serious gap in current descriptions of Haskell, both as a starting point for discussions about existing features of the type system, and as a platform from which to explore new proposals.},
author = {Jones, Mark P},
file = {:Users/edwin/Documents/Mendeley Desktop/Jones/Typing Haskell in Haskell/Jones - Typing Haskell in Haskell - 1999.pdf:pdf},
journal = {October},
publisher = {Citeseer},
title = {{Typing Haskell in Haskell}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.7274&amp;rep=rep1&amp;type=pdf},
year = {1999}
}
@book{Security2012,
author = {Pfleeger, Charles P and Pfleeger, S. L.},
booktitle = {Nicotine & tobacco research : official journal of the Society for Research on Nicotine and Tobacco},
doi = {10.1093/ntr/nts035},
file = {:Users/edwin/Documents/Mendeley Desktop/Pfleeger, Pfleeger/Security in Computing Chapter 3/Pfleeger, Pfleeger - Security in Computing Chapter 3 - 2012.pdf:pdf},
isbn = {0132390779},
issn = {1469-994X},
month = oct,
number = {10},
pages = {NP},
pmid = {23012339},
title = {{Security in Computing Chapter 3}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23012339},
volume = {14},
year = {2012}
}
@article{Steiner1988,
author = {Steiner, JG},
file = {:Users/edwin/Documents/Mendeley Desktop/Steiner/Kerberos An authentication service for open network systems/Steiner - Kerberos An authentication service for open network systems - 1988.pdf:pdf},
journal = {Proc. Winter USENIX Conference},
title = {{Kerberos: An authentication service for open network systems}},
url = {http://www.cse.nd.edu/$\sim$dthain/courses/cse598z/fall2004/papers/kerberos.pdf},
year = {1988}
}
@inproceedings{stump2010resource,
author = {Stump, A. and Austin, E.},
booktitle = {Proceedings of the 4th ACM SIGPLAN workshop on Programming languages meets program verification},
file = {:Users/edwin/Documents/Mendeley Desktop/Stump, Austin/Resource typing in Guru/Stump, Austin - Resource typing in Guru - 2010.pdf:pdf},
pages = {27--38},
publisher = {ACM},
title = {{Resource typing in Guru}},
url = {http://dl.acm.org/citation.cfm?id=1707796},
year = {2010}
}
@article{fisher2006next,
author = {Fisher, K. and Mandelbaum, Y. and Walker, D.},
file = {:Users/edwin/Documents/Mendeley Desktop/Fisher, Mandelbaum, Walker/The next 700 data description languages/Fisher, Mandelbaum, Walker - The next 700 data description languages - 2010.pdf:pdf},
journal = {Journal of the ACM},
number = {2},
pages = {1--51},
publisher = {ACM},
title = {{The next 700 data description languages}},
url = {http://dl.acm.org/citation.cfm?id=1111039},
volume = {15},
year = {2010}
}
@inproceedings{brady2011epic,
author = {Brady, Edwin},
booktitle = {Trends in Functional Programming ({TFP}’11)},
file = {:Users/edwin/Documents/Mendeley Desktop/Brady/Epic --- A Library for Generating Compilers/Brady - Epic --- A Library for Generating Compilers - 2011.pdf:pdf},
title = {{Epic --- A Library for Generating Compilers}},
url = {http://scholar.google.co.uk/scholar?cites=2588300990390214449&as_sdt=2005&sciodt=0,5&hl=en#1},
year = {2011}
}
@inproceedings{Brady2006b,
author = {Brady, Edwin},
booktitle = {Implementation and Application of Functional Languages ({IFL}'06)},
file = {:Users/edwin/Documents/Mendeley Desktop/Brady/Ivor, a proof engine/Brady - Ivor, a proof engine - 2006.pdf:pdf},
isbn = {978-3-540-74129-9},
month = sep,
pages = {145----162},
title = {{Ivor, a proof engine}},
url = {http://dl.acm.org/citation.cfm?id=1757028.1757037},
year = {2006}
}
@article{Reynolds1972,
abstract = {Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually defined by interpreters which are themselves written in a programming language based on the lambda calculus (i.e., an applicative language such as pure LISP). Examples include McCarthy's definition of LISP, Landin's SECD machine, the Vienna definition of PL/I, Reynolds' definitions of GEDANKEN, and recent unpublished work by L. Morris and C. Wadsworth. Such definitions can be classified according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call-by-value versus call-by-name) in the defined language depends upon the order of application in the defining language. As an example, we consider the definition of a simple applicative programming language by means of an interpreter written in a similar language. Definitions in each of the above classifications are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed.},
author = {Reynolds, John C},
file = {:Users/edwin/Documents/Mendeley Desktop/Reynolds/Definitional interpreters for higher-order programming languages/Reynolds - Definitional interpreters for higher-order programming languages - 1972.pdf:pdf},
journal = {Proceedings of the ACM annual conference on ACM 72},
keywords = {applicative language,closure,continuation,gedanken,higher order function,interpreter,j operator,lambda calculus,language definition,lisp,order application,pal,programming language,reference,secd machine},
number = {30602},
pages = {717--740},
publisher = {ACM Press},
title = {{Definitional interpreters for higher-order programming languages}},
volume = {2},
year = {1972}
}
@book{Hunt,
author = {Hunt, Andrew and Thomas, David},
booktitle = {Design},
file = {:Users/edwin/Documents/Mendeley Desktop/Hunt, Thomas/The Pragmatic Programmer Chapter 4/Hunt, Thomas - The Pragmatic Programmer Chapter 4 - Unknown.pdf:pdf},
isbn = {020161622X},
title = {{The Pragmatic Programmer Chapter 4}}
}
@article{Epstein2011,
author = {Epstein, Jeff and Black, Andrew P and Peyton-jones, Simon},
institution = {Microsoft Research},
journal = {researchmicrosoftcom},
number = {Section 8},
pages = {1--12},
title = {{Haskell for the cloud}},
url = {http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf},
year = {2011}
}
@book{Bertot2004,
author = {Bertot, Yves and Cast\'{e}ran, Pierre},
publisher = {Springer},
title = {{Interactive theorem proving and program development: {Coq'Art}: the {Calculus of Inductive Constructions}}},
url = {http://books.google.co.uk/books?hl=en&amp;lr=&amp;id=m5w5PRj5Nj4C&amp;oi=fnd&amp;pg=PA1&amp;dq=coq+theorem+prover&amp;ots=VHny1IYV0h&amp;sig=-K0FC67cdkhMDkAocFla8cZyRT4},
year = {2004}
}
@article{Swierstra2011,
author = {Swierstra, W},
file = {:Users/edwin/Documents/Mendeley Desktop/Swierstra/Sorted Verifying the Problem of the {Dutch National} Flag in {Agda}/Swierstra - Sorted Verifying the Problem of the {Dutch National} Flag in {Agda} - 2011.pdf:pdf},
journal = {Journal of Functional Programming},
number = {6},
pages = {575----583},
title = {{Sorted: Verifying the Problem of the {Dutch National} Flag in {Agda}}},
url = {http://journals.cambridge.org/abstract_S0956796811000207},
volume = {21},
year = {2011}
}
@misc{Casinghino2012,
author = {Casinghino, Chris and Sj\"{o}berg, Vilhelm and Weirich, Stephanie},
file = {:Users/edwin/Documents/Mendeley Desktop/Casinghino, Sj{o}berg, Weirich/Combining Proofs and Programs in a Dependently Typed Language/Casinghino, Sj{o}berg, Weirich - Combining Proofs and Programs in a Dependently Typed Language - 2012.pdf:pdf},
keywords = {dependent types,general recursion,termination},
pages = {1--12},
title = {{Combining Proofs and Programs in a Dependently Typed Language}},
year = {2012}
}
@article{Huet1997,
author = {Huet, G},
file = {:Users/edwin/Documents/Mendeley Desktop/Huet/The zipper/Huet - The zipper - 1997.pdf:pdf},
journal = {{Journal of Functional Programming}},
number = {5},
pages = {549----554},
title = {{The zipper}},
url = {http://journals.cambridge.org/abstract_S0956796897002864},
volume = {7},
year = {1997}
}
@inproceedings{bradyresource,
author = {Brady, Edwin and Hammond, Kevin},
booktitle = {Practical Applications of Declarative Languages ({PADL} 2012)},
file = {:Users/edwin/Documents/Mendeley Desktop/Brady, Hammond/Resource-safe Systems Programming with Embedded Domain Specific Languages/Brady, Hammond - Resource-safe Systems Programming with Embedded Domain Specific Languages - 2012.pdf:pdf},
pages = {242----257},
title = {{Resource-safe Systems Programming with Embedded Domain Specific Languages}},
url = {http://www.cs.st-andrews.ac.uk/$\sim$eb/drafts/dsl-idris.pdf},
year = {2012}
}
@book{Management,
author = {Totty, Brian and Gourley, David},
file = {:Users/edwin/Documents/Mendeley Desktop/Totty, Gourley/HTTP The Definitive Guide Chapter 4/Totty, Gourley - HTTP The Definitive Guide Chapter 4 - Unknown.pdf:pdf},
isbn = {1565925092},
title = {{HTTP: The Definitive Guide Chapter 4}}
}
@phdthesis{Brady2005,
author = {Brady, Edwin},
file = {:Users/edwin/Documents/Mendeley Desktop/Brady/Practical Implementation of a Dependently Typed Functional Programming Language/Brady - Practical Implementation of a Dependently Typed Functional Programming Language - 2005.pdf:pdf},
keywords = {Dependent Types},
mendeley-tags = {Dependent Types},
school = {University of Durham},
title = {{Practical Implementation of a Dependently Typed Functional Programming Language}},
year = {2005}
}
@article{Lee2001,
author = {Lee, Chin Soon and Jones, Neil D. and Ben-Amram, Amir M.},
doi = {10.1145/373243.360210},
file = {:Users/edwin/Documents/Mendeley Desktop/Lee, Jones, Ben-Amram/The size-change principle for program termination/Lee, Jones, Ben-Amram - The size-change principle for program termination - 2001.pdf:pdf},
isbn = {1-58113-336-7},
issn = {03621340},
journal = {{ACM SIGPLAN Notices}},
keywords = {PSPACE-completeness,omega automaton,partial evaluation,program analysis,termination},
month = mar,
number = {3},
pages = {81--92},
title = {{The size-change principle for program termination}},
url = {http://dl.acm.org/citation.cfm?id=373243.360210},
volume = {36},
year = {2001}
}
@misc{Bloat,
author = {Brooks, Fred},
file = {:Users/edwin/Documents/Mendeley Desktop/Brooks/The Design of Design Chapter 4/Brooks - The Design of Design Chapter 4 - Unknown.pdf:pdf},
isbn = {9780321702081},
title = {{The Design of Design Chapter 4}}
}
@misc{Caldwell,
author = {Caldwell, James and Roan, Ryan},
file = {:Users/edwin/Documents/Mendeley Desktop/Caldwell, Roan/Type Checking SQL for Secure Database Access/Caldwell, Roan - Type Checking SQL for Secure Database Access - Unknown.pdf:pdf},
title = {{Type Checking SQL for Secure Database Access}}
}
@inproceedings{Peterson1993,
address = {New York, New York, USA},
author = {Peterson, John and Jones, Mark},
booktitle = {Proceedings of the ACM SIGPLAN 1993 conference on Programming Language Design and Implementation - PLDI '93},
doi = {10.1145/155090.155112},
file = {:Users/edwin/Documents/Mendeley Desktop/Peterson, Jones/Implementing type classes/Peterson, Jones - Implementing type classes - 1993.pdf:pdf},
isbn = {0897915984},
issn = {0362-1340},
month = aug,
number = {6},
pages = {227--236},
publisher = {ACM Press},
title = {{Implementing type classes}},
url = {http://dl.acm.org/citation.cfm?id=155090.155112},
volume = {28},
year = {1993}
}
@misc{Attacks2012a,
author = {Anderson, Ross},
doi = {10.1093/epirev/mxr031},
file = {:Users/edwin/Documents/Mendeley Desktop/Anderson/Security Engineering Chapter 18/Anderson - Security Engineering Chapter 18 - Unknown.pdf:pdf},
isbn = {9780470068526},
issn = {1478-6729},
number = {1},
pages = {NP},
pmid = {22215642},
title = {{Security Engineering Chapter 18}},
volume = {34}
}
@inproceedings{bhargavan2010modular,
author = {Bhargavan, K. and Fournet, C. and Gordon, A.D.},
booktitle = {ACM Sigplan Notices},
number = {1},
pages = {445--456},
publisher = {ACM},
title = {{Modular verification of security protocol code by typing}},
url = {http://dl.acm.org/citation.cfm?id=1707801.1706350},
volume = {45},
year = {2010}
}
@article{Hoare1978,
abstract = {This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of a familiar programming exercises.},
author = {Hoare, C A R},
doi = {10.1016/0167-6423(87)90028-1},
editor = {McKeag, R M and Macnaghten, A M},
file = {:Users/edwin/Documents/Mendeley Desktop/Hoare/Communicating sequential processes/Hoare - Communicating sequential processes - 1978.pdf:pdf},
isbn = {0131532715},
issn = {01676423},
journal = {Communications of the ACM},
number = {8},
pages = {666--677},
pmid = {2142694823583477576},
publisher = {ACM},
series = {International Series in Computer Science},
title = {{Communicating sequential processes}},
url = {http://linkinghub.elsevier.com/retrieve/pii/0167642387900281},
volume = {21},
year = {1978}
}
@article{Overview,
author = {Totty, Brian and Gourley, David},
file = {:Users/edwin/Documents/Mendeley Desktop/Totty, Gourley/HTTP The Definitive Guide Chapter 1/Totty, Gourley - HTTP The Definitive Guide Chapter 1 - Unknown.pdf:pdf},
isbn = {1565925092},
title = {{HTTP: The Definitive Guide Chapter 1}}
}
@inproceedings{Sozeau2008,
author = {Sozeau, Matthieu and Oury, Nicolas},
booktitle = {Theorem Proving in Higher Order Logics ({TPHOLs 2008})},
file = {:Users/edwin/Documents/Mendeley Desktop/Sozeau, Oury/First-Class Type Classes/Sozeau, Oury - First-Class Type Classes - 2008.pdf:pdf},
pages = {278----293},
title = {{First-Class Type Classes}},
year = {2008}
}
@book{Fogel,
author = {Fogel, Karl},
file = {:Users/edwin/Documents/Mendeley Desktop/Fogel/Producing Open Source Software How to Run a Successful Free Software Project/Fogel - Producing Open Source Software How to Run a Successful Free Software Project - Unknown.pdf:pdf},
title = {{Producing Open Source Software: How to Run a Successful Free Software Project}}
}
@book{Brady2012,
author = {Hunt, Andrew and Thomas, David},
booktitle = {Carcinogenesis},
doi = {10.1093/carcin/bgs054},
file = {:Users/edwin/Documents/Mendeley Desktop/Hunt, Thomas/The Pragmatic Programmer Chapter 5/Hunt, Thomas - The Pragmatic Programmer Chapter 5 - Unknown.pdf:pdf},
isbn = {020161622X},
issn = {1460-2180},
number = {3},
pmid = {22383472},
title = {{The Pragmatic Programmer Chapter 5}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/22383472},
volume = {33}
}
@inproceedings{augustsson2008paradise,
author = {Augustsson, L. and Mansell, H. and Sittampalam, G.},
booktitle = {International Conference on Functional Programming},
file = {:Users/edwin/Documents/Mendeley Desktop/Augustsson, Mansell, Sittampalam/Paradise a two-stage DSL embedded in Haskell/Augustsson, Mansell, Sittampalam - Paradise a two-stage DSL embedded in Haskell - 2008.pdf:pdf},
number = {9},
pages = {225--228},
publisher = {ACM},
title = {{Paradise: a two-stage DSL embedded in Haskell}},
url = {http://dl.acm.org/citation.cfm?id=1411203.1411236},
volume = {43},
year = {2008}
}
@article{marlow2006making,
author = {Marlow, S. and {Peyton Jones}, S.},
file = {:Users/edwin/Documents/Mendeley Desktop/Marlow, Peyton Jones/Making a fast curry pushenter vs. evalapply for higher-order languages/Marlow, Peyton Jones - Making a fast curry pushenter vs. evalapply for higher-order languages - 2006.pdf:pdf},
journal = {Journal of Functional Programming},
number = {4-5},
pages = {415--449},
publisher = {Cambridge University Press},
title = {{Making a fast curry: push/enter vs. eval/apply for higher-order languages}},
url = {http://dl.acm.org/citation.cfm?id=1166018},
volume = {16},
year = {2006}
}
@misc{TheMendeleySupportTeam2011b,
abstract = {A quick introduction to Mendeley. Learn how Mendeley creates your personal digital library, how to organize and annotate documents, how to collaborate and share with colleagues, and how to generate citations and bibliographies.},
address = {London},
author = {{The Mendeley Support Team}},
booktitle = {Mendeley Desktop},
file = {:Users/edwin/Documents/Mendeley Desktop/The Mendeley Support Team/Getting Started with Mendeley/The Mendeley Support Team - Getting Started with Mendeley - 2011.pdf:pdf},
keywords = {Mendeley,how-to,user manual},
pages = {1--16},
publisher = {Mendeley Ltd.},
title = {{Getting Started with Mendeley}},
url = {http://www.mendeley.com},
year = {2011}
}
@inproceedings{ko2011modularising,
author = {Ko, H.S. and Gibbons, J.},
booktitle = {Proceedings of the seventh ACM SIGPLAN workshop on Generic programming},
pages = {13--24},
publisher = {ACM},
title = {{Modularising inductive families}},
url = {http://dl.acm.org/citation.cfm?id=2036921},
year = {2011}
}
@book{Fry1985,
author = {Abelson, Harold and Sussman, Gerald and Sussman, Julie},
booktitle = {Computer Music Journal},
doi = {10.2307/3679579},
file = {:Users/edwin/Documents/Mendeley Desktop/Abelson, Sussman, Sussman/Structure and Interpretation of Computer Programs/Abelson, Sussman, Sussman - Structure and Interpretation of Computer Programs - 1985.pdf:pdf},
isbn = {0262011530},
issn = {01489267},
month = jan,
number = {3},
title = {{Structure and Interpretation of Computer Programs}},
url = {http://www.jstor.org/stable/3679579?origin=crossref},
volume = {9},
year = {1985}
}
@article{Bird2012,
annote = {I enjoyed reading this pearl. It describes, clearly and concisely, the calculation of a program for changing the way of representing a graph in response to a challenge of Donald Knuth's, who asked whether such an algorithm could be discovered in a "disciplined manner". The paper describes that disciplined manner.

        

        
In general, I found the paper easy to follow. Section 2 sets up the problem, giving a purely functional representation of graphs and the definitions of some basic, important functions, in particular encode and decode. Section 3 gives a first example of program calculation, assuming the existence of a function 'lengthen' corresponding to 'shorten' and deriving an implementation from its required properties. Later, we see a definition using arrays rather than lists in order to improve the complexity to linear time. Section 4 addresses a condition Knuth imposes, namely that update must be in place and gives an imperative translation.

        
I think this paper gives a nice example of program calculation leading from a functional specification to an imperative program. I do have a few suggestions though which I think would improve the paper:

        
In the introduction, you say there is a reason why the code cannot be purely functional, but I don't see an explicit explanation of why this is. In place update perhaps? Can this be clarified?

        
The equation numbering, e.g. (1) at the bottom of p1 - some equations are clearly important and referred to elsewhere, such as this one. Is it possible to make these stand out more? e.g. with an explicit heading "Equation 1"?

        
p3 In the first examples of program calculation, it is easy to follow the reasoning of why the calculation is correct, but it is not so obvious what the insight was that led to the calculation. Is this simply a matter of experience?

        
p6 I'm surprised to read that // updates an array in place. Is this really what is happening or is there a clever representation of Data.Array.Diff? It appears to use IO operations internally. So it might be nice to say a little more about what is really going on.

        
p7 "...an observation that could have been made earlier" seems an odd thing to say. Why not either make it earlier, or just make it here where it is used?

        
p9 There is no need to give the translation rules to the imperative code in detail, but it would still be useful to sketch what is going on. It seems that the foldr becomes the outer for loop, and apply the inner for loop. It would also be useful, in Figs 1-4 to give the functional code alongside the imperative versions. It is interesting to examine how the mapping works and I think an important point made by the paper (as indeed you say in the conclusion).

        
p14 The last paragraph appears to be largely a comment to the present referees! 

      },
author = {Bird, Richard S},
file = {:Users/edwin/Documents/Mendeley Desktop/Bird/An in-situ algorithm for expanding a graph/Bird - An in-situ algorithm for expanding a graph - 2012(2).pdf:pdf},
journal = {Journal of Functional Programming},
keywords = {a href,journal of functional programming},
title = {{An in-situ algorithm for expanding a graph}},
year = {2012}
}
@article{Ahn,
annote = {-1,5

        
The paper describes Nax, a new functional programming language with term indices which supports logical consistency and Hindley-Milner style type inference. The authors give four key features of Nax (1: strong normalization, 2: type inference, 3: expressivity and 4: support for term indices) and give several examples to demonstrate the simplicity of programming in Nax as compared with Haskell and Agda. Three examples are given, in each language: a type preserving evaluator for an expression language, a generic Path datatype which describes a path through an index type, and a stack safe compiler for the expression language.

        
Presenting examples in this way gives a nice introduction to Nax, in that they are well understood examples already and it is easy to relate them to implementations with which the reader is already familiar. On the other hand, this leads to my main problem with this paper: it doesn't really tell us anything we don't already know, and the promising things about Nax which *would* be an interesting contribution are left out of the paper.

        
Of the four features of Nax given above, 1 and 2 are described as "beyond the scope of this paper" which is a shame because these are the things I'm most interested in hearing about! Existing dependently typed languages lack type inference, and whlie I would argue that it is usually best to write types first in any case, there are still many situations where recovering type inference would be useful - typically small or simply typed helper functions. So this would have been a very nice technical contribution.

        
The third feature (expressivity) is one that the authors claim as a contribution of the paper. They claim that programming in Nax is as "simple" as programming in Haskell or Agda. However, I think this is a strong claim to make given the available evidence - it is quite subjective. I agree that the programs are quite easy to read, but to say that *programming* is as simple really requires some externally verified evidence from other programmers! It seems to me that programming with Mendler-style combinators may take some practice, for example.

        
In summary, I do like the idea behind Nax and some of its features sound as if they could be interesting, and I think this latest contribution to the design space of dependently typed functional programming is welcome. But this paper does not really provide any new insights as it stands.

        
Minor comments:

        
Fig 1,2 and 3 - I'm not sure I would like the rotation of these in print (it's pretty awkward on screen too).},
author = {Ahn, Ki Yung and Sheard, Tim and Fiore, Marcelo and Pitts, Andrew M},
file = {:Users/edwin/Documents/Mendeley Desktop/Ahn et al/Programming with Term-Indexed Types in Nax/Ahn et al. - Programming with Term-Indexed Types in Nax - Unknown.pdf:pdf},
keywords = {gadts,indexed datatypes,lightweight dependent types,term-indexed types,universe polymorphism,universe subtyping},
title = {{Programming with Term-Indexed Types in Nax}}
}
@article{Morrisett1999,
author = {Morrisett, G and Walker, D},
file = {:Users/edwin/Documents/Mendeley Desktop/Morrisett, Walker/From System F to typed assembly language/Morrisett, Walker - From System F to typed assembly language - 1999.pdf:pdf},
journal = {ACM Transactions on  \ldots},
title = {{From System F to typed assembly language}},
url = {http://dl.acm.org/citation.cfm?id=319345},
year = {1999}
}
@article{Altenkirch2010a,
abstract = {We begin by revisiting the idea of using a universe of types to write generic programs in a dependently typed setting by constructing a universe for Strictly Positive Types (SPTs). Here we extend this construction to cover dependent types, i.e. Strictly Positive Families (SPFs), thereby fixing a gap left open in previous work. Using the approach presented here we are able to represent all of Epigrams datatypes within Epigram including the universe of datatypes itself.},
author = {Altenkirch, Thorsten and Mcbride, Conor and Morris, Peter},
file = {:Users/edwin/Documents/Mendeley Desktop/Altenkirch, Mcbride, Morris/Generic Programming with Dependent Types/Altenkirch, Mcbride, Morris - Generic Programming with Dependent Types - 2010.pdf:pdf},
journal = {Citeseer},
publisher = {Citeseer},
title = {{Generic Programming with Dependent Types}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.2926&amp;rep=rep1&amp;type=pdf},
year = {2010}
}
@book{Edition2012a,
author = {Pfleeger, Charles P and Pfleeger, S. L.},
booktitle = {Nicotine & tobacco research : official journal of the Society for Research on Nicotine and Tobacco},
doi = {10.1093/ntr/nts035},
file = {:Users/edwin/Documents/Mendeley Desktop/Pfleeger, Pfleeger/Security in Computer Chapter 12/Pfleeger, Pfleeger - Security in Computer Chapter 12 - 2012.pdf:pdf},
isbn = {0132390779},
issn = {1469-994X},
month = oct,
number = {10},
pages = {NP},
pmid = {23012339},
title = {{Security in Computer Chapter 12}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/23012339},
volume = {14},
year = {2012}
}
@book{Pierce2004,
author = {Pierce, Benjamin},
editor = {Pierce, Benjamin},
file = {:Users/edwin/Documents/Mendeley Desktop/Pierce/Advanced topics in types and programming languages/Pierce - Advanced topics in types and programming languages - 2004.pdf:pdf},
publisher = {MIT Press},
title = {{Advanced topics in types and programming languages}},
year = {2004}
}
@inproceedings{taha1997multi,
author = {Taha, W. and Sheard, T.},
booktitle = {ACM SIGPLAN Notices},
number = {12},
pages = {203--217},
publisher = {ACM},
title = {{Multi-stage programming with explicit annotations}},
url = {http://dl.acm.org/citation.cfm?id=259019},
volume = {32},
year = {1997}
}
@misc{Lorenzen,
author = {Lorenzen, Florian},
file = {:Users/edwin/Documents/Mendeley Desktop/Lorenzen/A Statically Typed Functional Language With Programmable Binders/Lorenzen - A Statically Typed Functional Language With Programmable Binders - Unknown.pdf:pdf},
title = {{A Statically Typed Functional Language With Programmable Binders}}
}
@book{The2012,
author = {Hunt, Andrew and Thomas, David},
booktitle = {Carcinogenesis},
doi = {10.1093/carcin/bgs054},
file = {:Users/edwin/Documents/Mendeley Desktop/Hunt, Thomas/The Pragmatic Programmer Chapter 3/Hunt, Thomas - The Pragmatic Programmer Chapter 3 - Unknown.pdf:pdf},
isbn = {020161622X},
issn = {1460-2180},
number = {3},
pmid = {22383472},
title = {{The Pragmatic Programmer Chapter 3}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/22383472},
volume = {33}
}
@inproceedings{pollack1990implicit,
author = {Pollack, R.},
booktitle = {{Informal Proceedings of First Workshop on Logical Frameworks, Antibes}},
file = {:Users/edwin/Documents/Mendeley Desktop/Pollack/Implicit syntax/Pollack - Implicit syntax - 1990.pdf:pdf},
publisher = {Citeseer},
title = {{Implicit syntax}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.30.7361&amp;rep=rep1&amp;type=pdf},
year = {1990}
}
@article{Bradya,
author = {Hunt, Andrew and Thomas, David},
file = {:Users/edwin/Documents/Mendeley Desktop/Hunt, Thomas/The Pragmatic Programmer Chapter 7/Hunt, Thomas - The Pragmatic Programmer Chapter 7 - Unknown.pdf:pdf},
isbn = {020161622X},
title = {{The Pragmatic Programmer Chapter 7}}
}
