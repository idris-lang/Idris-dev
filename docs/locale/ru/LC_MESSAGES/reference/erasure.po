# 
msgid ""
msgstr ""
"Project-Id-Version: Idris 0.9.17\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-05-20 17:05+0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\reference\erasure.rst:3
msgid "Erasure By Usage Analysis"
msgstr ""

#: ..\..\reference\erasure.rst:5
msgid ""
"This work stems from this `feature proposal <https://github.com/idris-lang"
"/Idris-dev/wiki/Egg-%232%3A-Erasure-annotations>`__ (obsoleted by this "
"page). Beware that the information in the proposal is out of date — and "
"sometimes even in direct contradiction with the eventual implementation."
msgstr ""

#: ..\..\reference\erasure.rst:12
msgid "Motivation"
msgstr ""

#: ..\..\reference\erasure.rst:14
msgid ""
"Traditional dependently typed languages (Agda, Coq) are good at erasing "
"*proofs* (either via irrelevance or an extra universe)."
msgstr ""

#: ..\..\reference\erasure.rst:23
msgid ""
"For example, in the above snippet, the second argument is a proof, which is "
"used only to convince the compiler that the function is total. This proof is"
" never inspected at runtime and thus can be erased. In this case, the mere "
"existence of the proof is sufficient and we can use irrelevance-related "
"methods to achieve erasure."
msgstr ""

#: ..\..\reference\erasure.rst:29
msgid ""
"However, sometimes we want to erase *indices* and this is where the "
"traditional approaches stop being useful, mainly for reasons described in "
"the `original proposal <https://github.com/idris-lang/Idris-"
"dev/wiki/Egg-%232%3A-Erasure-annotations#prop-is-cumbersome-coq>`__."
msgstr ""

#: ..\..\reference\erasure.rst:41
msgid ""
"Notice that in this case, the second argument is the important one and we "
"would like to get rid of the ``n`` instead, although the shape of the "
"program is generally the same as in the previous case."
msgstr ""

#: ..\..\reference\erasure.rst:45
msgid ""
"There are methods described by Brady, McBride and McKinna in [BMM04]_ to "
"remove the indices from data structures, exploiting the fact that functions "
"operating on them either already have a copy of the appropriate index or the"
" index can be quickly reconstructed if needed. However, we often want to "
"erase the indices altogether, from the whole program, even in those cases "
"where reconstruction is not possible."
msgstr ""

#: ..\..\reference\erasure.rst:52
msgid ""
"The following two sections describe two cases where doing so improves the "
"runtime performance asymptotically."
msgstr ""

#: ..\..\reference\erasure.rst:56
msgid "Binary numbers"
msgstr ""

#: ..\..\reference\erasure.rst:58
msgid "O(n) instead of O(log n)"
msgstr ""

#: ..\..\reference\erasure.rst:60
msgid ""
"Consider the following ``Nat``-indexed type family representing binary "
"numbers:"
msgstr ""

#: ..\..\reference\erasure.rst:70
msgid ""
"These are supposed to be (at least asymptotically) fast and memory-efficient"
" because their size is logarithmic compared to the numbers they represent."
msgstr ""

#: ..\..\reference\erasure.rst:74
msgid ""
"Unfortunately this is not the case. The problem is that these binary numbers"
" still carry the *unary* indices with them, performing arithmetic on the "
"indices whenever arithmetic is done on the binary numbers themselves. Hence "
"the real representation of the number 15 looks like this:"
msgstr ""

#: ..\..\reference\erasure.rst:92
msgid ""
"The used memory is actually *linear*, not logarithmic and therefore we "
"cannot get below O(n) with time complexities."
msgstr ""

#: ..\..\reference\erasure.rst:95
msgid ""
"One could argue that Idris in fact compiles ``Nat`` via GMP but that's a "
"moot point for two reasons:"
msgstr ""

#: ..\..\reference\erasure.rst:98
msgid ""
"First, whenever we try to index our datastructures with anything else than "
"``Nat``, the compiler is not going to come to the rescue."
msgstr ""

#: ..\..\reference\erasure.rst:101
msgid ""
"Second, even with ``Nat``, the GMP integers are *still* there and they slow "
"the runtime down."
msgstr ""

#: ..\..\reference\erasure.rst:104
msgid ""
"This ought not to be the case since the ``Nat`` are never used at runtime "
"and they are only there for typechecking purposes. Hence we should get rid "
"of them and get runtime code similar to what a idris programmer would write."
msgstr ""

#: ..\..\reference\erasure.rst:110
msgid "U-views of lists"
msgstr ""

#: ..\..\reference\erasure.rst:112
msgid "O(n^2) instead of O(n)"
msgstr ""

#: ..\..\reference\erasure.rst:114
msgid "Consider the type of U-views of lists:"
msgstr ""

#: ..\..\reference\erasure.rst:123
msgid ""
"For better intuition, the shape of the U-view of ``[x0,x1,x2,z,y2,y1,y0]`` "
"looks like this:"
msgstr ""

#: ..\..\reference\erasure.rst:133
msgid ""
"When recursing over this structure, the values of ``xs`` range over "
"``[x0,x1,x2,z,y2,y1,y0]``, ``[x1,x2,z,y2,y1]``, ``[x2,z,y2]``, ``[z]``.  No "
"matter whether these lists are stored or built on demand, they take up a "
"quadratic amount of memory (because they cannot share nodes), and hence it "
"takes a quadratic amount of time just to build values of this index alone."
msgstr ""

#: ..\..\reference\erasure.rst:140
msgid ""
"But the reasonable expectation is that operations with U-views take linear "
"time — so we need to erase the index ``xs`` if we want to achieve this goal."
msgstr ""

#: ..\..\reference\erasure.rst:145
msgid "Changes to Idris"
msgstr ""

#: ..\..\reference\erasure.rst:147
msgid ""
"Usage analysis is run at every compilation and its outputs are used for "
"various purposes. This is actually invisible to the user but it's a "
"relatively big and important change, which enables the new features."
msgstr ""

#: ..\..\reference\erasure.rst:151
msgid ""
"Everything that is found to be unused is erased. No annotations are needed, "
"just don't use the thing and it will vanish from the generated code. "
"However, if you wish, you can use the dot annotations to get a warning if "
"the thing is accidentally used."
msgstr ""

#: ..\..\reference\erasure.rst:156
msgid ""
"\"Being used\" in this context means that the value of the \"thing\" may "
"influence run-time behaviour of the program. (More precisely, it is not "
"found to be irrelevant to the run-time behaviour by the usage analysis "
"algorithm.)"
msgstr ""

#: ..\..\reference\erasure.rst:161
msgid "\"Things\" considered for removal by erasure include:"
msgstr ""

#: ..\..\reference\erasure.rst:163
msgid "function arguments"
msgstr ""

#: ..\..\reference\erasure.rst:165
msgid ""
"data constructor fields (including record fields and dictionary fields of "
"class instances)"
msgstr ""

#: ..\..\reference\erasure.rst:168
msgid ""
"For example, ``Either`` often compiles to the same runtime representation as"
" ``Bool``. Constructor field removal sometimes combines with the newtype "
"optimisation to have quite a strong effect."
msgstr ""

#: ..\..\reference\erasure.rst:172
msgid ""
"There is a new compiler option ``--warnreach``, which will enable warnings "
"coming from erasure. Since we have full usage analysis, we can compile even "
"those programs that violate erasure annotations -- it's just that the "
"binaries may run slower than expected. The warnings will be enabled by "
"default in future versions of Idris (and possibly turned to errors). "
"However, in this transitional period, we chose to keep them on-demand to "
"avoid confusion until better documentation is written."
msgstr ""

#: ..\..\reference\erasure.rst:181
msgid ""
"Case-tree elaboration tries to avoid using dotted \"things\" whenever "
"possible. (NB. This is not yet perfect and it's being worked on: "
"https://gist.github.com/ziman/10458331)"
msgstr ""

#: ..\..\reference\erasure.rst:185
msgid ""
"Postulates are no longer required to be collapsible. They are now required "
"to be *unused* instead."
msgstr ""

#: ..\..\reference\erasure.rst:189
msgid "Changes to the language"
msgstr ""

#: ..\..\reference\erasure.rst:191
msgid ""
"You can use dots to mark fields that are not intended to be used at runtime."
msgstr ""

#: ..\..\reference\erasure.rst:201
msgid ""
"If these fields are found to be used at runtime, the dots will trigger a "
"warning (with ``--warnreach``)."
msgstr ""

#: ..\..\reference\erasure.rst:204
msgid ""
"Note that free (unbound) implicits are dotted by default so, for example, "
"the constructor ``O`` can be defined as:"
msgstr ""

#: ..\..\reference\erasure.rst:211
msgid "and this is actually the preferred form."
msgstr ""

#: ..\..\reference\erasure.rst:213
msgid ""
"If you have a free implicit which is meant to be used at runtime, you have "
"to change it into an (undotted) ``{bound : implicit}``."
msgstr ""

#: ..\..\reference\erasure.rst:216
msgid "You can also put dots in types of functions to get more guarantees."
msgstr ""

#: ..\..\reference\erasure.rst:222
msgid "and free implicits are automatically dotted here, too."
msgstr ""

#: ..\..\reference\erasure.rst:225
msgid "What it means"
msgstr ""

#: ..\..\reference\erasure.rst:227
msgid "Dot annotations serve two purposes:"
msgstr ""

#: ..\..\reference\erasure.rst:229
msgid "influence case-tree elaboration to avoid dotted variables"
msgstr ""

#: ..\..\reference\erasure.rst:231
msgid "trigger warnings when a dotted variable is used"
msgstr ""

#: ..\..\reference\erasure.rst:233
msgid ""
"However, there's no direct connection between being dotted and being erased."
" The compiler erases everything it can, dotted or not. The dots are there "
"mainly to help the programmer (and the compiler) refrain from using the "
"values they want to erase."
msgstr ""

#: ..\..\reference\erasure.rst:239
msgid "How to use it"
msgstr ""

#: ..\..\reference\erasure.rst:241
msgid ""
"Ideally, few or no extra annotations are needed -- in practice, it turns out"
" that having free implicits automatically dotted is enough to get good "
"erasure."
msgstr ""

#: ..\..\reference\erasure.rst:245
msgid ""
"Therefore, just compile with ``--warnreach`` to see warnings if erasure "
"cannot remove parts of the program."
msgstr ""

#: ..\..\reference\erasure.rst:248
msgid ""
"However, those programs that have been written without runtime behaviour in "
"mind, will need some help to get in the form that compiles to a reasonable "
"binary. Generally, it's sufficient to follow erasure warnings (which may be "
"sometimes unhelpful at the moment)."
msgstr ""

#: ..\..\reference\erasure.rst:254
msgid "Benchmarks"
msgstr ""

#: ..\..\reference\erasure.rst:256
msgid "source: https://github.com/ziman/idris-benchmarks"
msgstr ""

#: ..\..\reference\erasure.rst:257
msgid "results: http://ziman.functor.sk/erasure-bm/"
msgstr ""

#: ..\..\reference\erasure.rst:259
msgid "It can be clearly seen that asymptotics are improved by erasure."
msgstr ""

#: ..\..\reference\erasure.rst:262
msgid "Shortcomings"
msgstr ""

#: ..\..\reference\erasure.rst:264
msgid ""
"You can't get warnings in libraries because usage analysis starts from "
"``Main.main``. This will be solved by the planned ``%default_usage`` pragma."
msgstr ""

#: ..\..\reference\erasure.rst:268
msgid ""
"Usage warnings are quite bad and unhelpful at the moment. We should include "
"more information and at least translate argument numbers to their names."
msgstr ""

#: ..\..\reference\erasure.rst:272
msgid "There is no decent documentation yet. This wiki page is the first one."
msgstr ""

#: ..\..\reference\erasure.rst:274
msgid ""
"There is no generally accepted terminology. We switch between \"dotted\", "
"\"unused\", \"erased\", \"irrelevant\", \"inaccessible\", while each has a "
"slightly different meaning. We need more consistent and understandable "
"naming."
msgstr ""

#: ..\..\reference\erasure.rst:279
msgid ""
"If the same type is used in both erased and non-erased context, it will "
"retain its fields to accomodate the least common denominator -- the non-"
"erased context. This is particularly troublesome in the case of the type of "
"(dependent) pairs, where it actually means that no erasure would be "
"performed. We should probably locate disjoint uses of data types and split "
"them into \"sub-types\". There are three different flavours of dependent "
"types now: ``Sigma`` (nothing erased), ``Exists`` (first component erased), "
"``Subset`` (second component erased)."
msgstr ""

#: ..\..\reference\erasure.rst:289
msgid ""
"Case-tree building does not avoid dotted values coming from pattern-matched "
"constructors (https://gist.github.com/ziman/10458331). This is to be fixed "
"soon. (Fixed.)"
msgstr ""

#: ..\..\reference\erasure.rst:293
msgid ""
"Higher-order function arguments and opaque functional variables are "
"considered to be using all their arguments. To work around this, you can "
"force erasure via the type system, using the ``Erased`` wrapper: "
"https://github.com/idris-lang/Idris-"
"dev/blob/master/libs/base/Data/Erased.idr"
msgstr ""

#: ..\..\reference\erasure.rst:298
msgid ""
"Typeclass methods are considered to be using the union of all their "
"implementations. In other words, an argument of a method is unused only if "
"it is unused in every implementation of the method that occurs in the "
"program."
msgstr ""

#: ..\..\reference\erasure.rst:304
msgid "Planned features"
msgstr ""

#: ..\..\reference\erasure.rst:306
msgid "Fixes to the above shortcomings in general."
msgstr ""

#: ..\..\reference\erasure.rst:309
msgid "Improvements to the case-tree elaborator so that it properly avoids"
msgstr ""

#: ..\..\reference\erasure.rst:309
msgid "dotted fields of data constructors. Done."
msgstr ""

#: ..\..\reference\erasure.rst:317
msgid "Compiler pragma ``%default_usage used/unused`` and per-function"
msgstr ""

#: ..\..\reference\erasure.rst:312
msgid ""
"overrides ``used`` and ``unused``, which allow the programmer to mark the "
"return value of a function as used, even if the function is not used in "
"``main`` (which is the case when writing library code). These annotations "
"will help library writers discover usage violations in their code before it "
"is actually published and used in compiled programs."
msgstr ""

#: ..\..\reference\erasure.rst:320
msgid "Troubleshooting"
msgstr ""

#: ..\..\reference\erasure.rst:323
msgid "My program is slower"
msgstr ""

#: ..\..\reference\erasure.rst:325
msgid ""
"The patch introducing erasure by usage analysis also disabled some "
"optimisations that were in place before; these are subsumed by the new "
"erasure. However, in some erasure-unaware programs, where erasure by usage "
"analysis does not exercise its full potential (but the old optimisations "
"would have worked), certain slowdown may be observed (up to ~10% according "
"to preliminary benchmarking), due to retention and computation of "
"information that should not be necessary at runtime."
msgstr ""

#: ..\..\reference\erasure.rst:333
msgid ""
"A simple check whether this is the case is to compile with ``--warnreach``. "
"If you see warnings, there is some unnecessary code getting compiled into "
"the binary."
msgstr ""

#: ..\..\reference\erasure.rst:337
msgid "The solution is to change the code so that there are no warnings."
msgstr ""

#: ..\..\reference\erasure.rst:340
msgid "Usage warnings are unhelpful"
msgstr ""

#: ..\..\reference\erasure.rst:342
msgid ""
"This is a known issue and we are working on it. For now, see the section "
"`How to read and resolve erasure warnings <#how-to-read-and-resolve-erasure-"
"warnings>`__."
msgstr ""

#: ..\..\reference\erasure.rst:347
msgid "There should be no warnings in this function"
msgstr ""

#: ..\..\reference\erasure.rst:349
msgid ""
"A possible cause is non-totality of the function (more precisely, non-"
"coverage). If a function is non-covering, the program needs to inspect all "
"arguments in order to detect coverage failures at runtime. Since the "
"function inspects all its arguments, nothing can be erased and this may "
"transitively cause usage violations. The solution is to make the function "
"total or accept the fact that it will use its arguments and remove some dots"
" from the appropriate constructor fields and function arguments. (Please "
"note that this is not a shortcoming of erasure and there is nothing we can "
"do about it.)"
msgstr ""

#: ..\..\reference\erasure.rst:359
msgid ""
"Another possible cause is the currently imperfect case-tree elaboration, "
"which does not avoid dotted constructor fields (see "
"https://gist.github.com/ziman/10458331). You can either rephrase the "
"function or wait until this is fixed, hopefully soon. Fixed."
msgstr ""

#: ..\..\reference\erasure.rst:365
msgid "The compiler refuses to recognise this thing as erased"
msgstr ""

#: ..\..\reference\erasure.rst:367
msgid ""
"You can force anything to be erased by wrapping it in the ``Erased`` monad. "
"While this program triggers usage warnings,"
msgstr ""

#: ..\..\reference\erasure.rst:375
msgid "the following program does not:"
msgstr ""

#: ..\..\reference\erasure.rst:383
msgid "How to read and resolve erasure warnings"
msgstr ""

#: ..\..\reference\erasure.rst:386
msgid "Example 1"
msgstr ""

#: ..\..\reference\erasure.rst:388
msgid "Consider the following program:"
msgstr ""

#: ..\..\reference\erasure.rst:402
msgid "When you compile it using ``--warnreach``, there is one warning:"
msgstr ""

#: ..\..\reference\erasure.rst:409
msgid ""
"The warning does not contain much detail at this point so we can try "
"compiling with ``--dumpcases cases.txt`` and look up the compiled definition"
" in ``cases.txt``:"
msgstr ""

#: ..\..\reference\erasure.rst:420
msgid ""
"The reason for the warning is that ``sumLengths`` calls ``vlen``, which gets"
" inlined. The second clause of ``sumLengths`` then accesses the variable "
"``n``, compiled as ``{e0}``. Since ``n`` is a free implicit, it is "
"automatically considered dotted and this triggers the warning."
msgstr ""

#: ..\..\reference\erasure.rst:425
msgid ""
"A solution would be either making the argument ``n`` a bound implicit "
"parameter to indicate that we wish to keep it at runtime,"
msgstr ""

#: ..\..\reference\erasure.rst:432
msgid "or fixing ``vlen`` to not use the index:"
msgstr ""

#: ..\..\reference\erasure.rst:440
msgid "Which solution is appropriate depends on the usecase."
msgstr ""

#: ..\..\reference\erasure.rst:443
msgid "Example 2"
msgstr ""

#: ..\..\reference\erasure.rst:445
msgid ""
"Consider the following program manipulating value-indexed binary numbers."
msgstr ""

#: ..\..\reference\erasure.rst:463
msgid ""
"In the function ``toN``, we attempted to \"cheat\" and instead of traversing"
" the whole structure, we just projected the value index ``n`` out of "
"constructors ``I`` and ``O``. However, this index is a free implicit, "
"therefore it is considered dotted."
msgstr ""

#: ..\..\reference\erasure.rst:468
msgid ""
"Inspecting it then produces the following warnings when compiling with "
"``--warnreach``:"
msgstr ""

#: ..\..\reference\erasure.rst:478
msgid ""
"We can see that the argument ``n`` of both ``I`` and ``O`` is used in the "
"function ``toN``, argument 1."
msgstr ""

#: ..\..\reference\erasure.rst:481
msgid ""
"At this stage of development, warnings only contain argument numbers, not "
"names; this will hopefully be fixed. When numbering arguments, we go from 0,"
" taking free implicits first, left-to-right; then the bound arguments. The "
"function ``toN`` has therefore in fact two arguments: ``n`` (argument 0) and"
" ``b`` (argument 1). And indeed, as the warning says, we project the dotted "
"field from ``b``."
msgstr ""

#: ..\..\reference\erasure.rst:488
msgid ""
"Again, one solution is to fix the function ``toN`` to calculate its result "
"honestly; the other one is to accept that we carry a ``Nat`` with every "
"constructor of ``Bin`` and make it a bound implicit:"
msgstr ""

#: ..\..\reference\erasure.rst:498
msgid "References"
msgstr ""

#: ..\..\reference\erasure.rst:500
msgid ""
"Edwin Brady, Conor McBride, James McKinna: `Inductive families need not "
"store their indices "
"<http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=1F796FCF0F2C4C535FC70F62BE2FB821?doi=10.1.1.62.3849>`__"
msgstr ""
