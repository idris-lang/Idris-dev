# 
msgid ""
msgstr ""
"Project-Id-Version: Idris 0.9.17\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-05-20 17:05+0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\reference\uniqueness-types.rst:3
msgid "Uniqueness Types"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:5
msgid ""
"Uniqueness Types are an experimental feature available from Idris 0.9.15. A "
"value with a unique type is guaranteed to have *at most one* reference to it"
" at run-time, which means that it can safely be updated in-place, reducing "
"the need for memory allocation and garbage collection. The motivation is "
"that we would like to be able to write reactive systems, programs which run "
"in limited memory environments, device drivers, and any other system with "
"hard real-time requirements, ideally while giving up as little high level "
"conveniences as possible."
msgstr ""

#: ..\..\reference\uniqueness-types.rst:14
msgid ""
"They are inspired by linear types, `Uniqueness Types "
"<https://en.wikipedia.org/wiki/Uniqueness_type>`__ in the `Clean "
"<http://wiki.clean.cs.ru.nl/Clean>`__ programming language, and ownership "
"types and borrowed pointers in the `Rust <http://www.rust-lang.org/>`__ "
"programming language."
msgstr ""

#: ..\..\reference\uniqueness-types.rst:20
msgid ""
"Some things we hope to be able to do eventually with uniqueness types "
"include:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:23
msgid "Safe, pure, in-place update of arrays, lists, etc"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:24
msgid "Provide guarantees of correct resource usage, state transitions, etc"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:25
msgid ""
"Provide guarantees that critical program fragments will *never* allocate"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:29
msgid "Using Uniqueness"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:31
msgid ""
"If ``x : T`` and ``T : UniqueType``, then there is at most one reference to "
"``x`` at any time during run-time execution. For example, we can declare the"
" type of unique lists as follows:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:41
msgid ""
"If we have a value ``xs : UList a``, then there is at most one reference to "
"``xs`` at run-time. The type checker preserves this guarantee by ensuring "
"that there is at most one reference to any value of a unique type in a "
"pattern clause. For example, the following function definition would be "
"valid:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:53
msgid ""
"In the second clause, ``xs`` is a value of a unique type, and only appears "
"once on the right hand side, so this clause is valid. Not only that, since "
"we know there can be no other reference to the ``UList a`` argument, we can "
"reuse its space for building the result! The compiler is aware of this, and "
"compiles this definition to an in-place update of the list."
msgstr ""

#: ..\..\reference\uniqueness-types.rst:60
msgid ""
"The following function definition would not be valid (even assuming an "
"implementation of ``++``), however, since ``xs`` appears twice:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:68
msgid ""
"This would result in a shared pointer to ``xs``, so the typechecker reports:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:75
msgid "If we explicitly copy, however, the typechecker is happy:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:83
msgid ""
"Note that it's fine to use ``x`` twice, because ``a`` is a ``Type``, rather "
"than a ``UniqueType``."
msgstr ""

#: ..\..\reference\uniqueness-types.rst:86
msgid ""
"There are some other restrictions on where a ``UniqueType`` can appear, so "
"that the uniqueness property is preserved. In particular, the type of the "
"function type, ``(x : a) -> b`` depends on the type of ``a`` or ``b`` - if "
"either is a ``UniqueType``, then the function type is also a ``UniqueType``."
" Then, in a data declaration, if the type constructor builds a ``Type``, "
"then no constructor can have a ``UniqueType``. For example, the following "
"definition is invalid, since it would embed a unique value in a possible "
"non-unique value:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:101
msgid ""
"Finally, types may be polymorphic in their uniqueness, to a limited extent. "
"Since ``Type`` and ``UniqueType`` are different types, we are limited in how"
" much we can use polymorphic functions on unique types. For example, if we "
"have function composition defined as follows:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:111
msgid "And we have some functions over unique types:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:118
msgid ""
"Then we cannot compose ``foo`` and ``bar`` as ``bar . foo``, because "
"``UList`` does not compute a ``Type``! Instead, we can define composition as"
" follows:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:127
msgid ""
"The ``Type*`` type stands for either unique or non-unique types. Since such "
"a function may be passed a ``UniqueType``, any value of type ``Type*`` must "
"also satisfy the requirement that it appears at most once on the right hand "
"side."
msgstr ""

#: ..\..\reference\uniqueness-types.rst:133
msgid "Borrowed Types"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:135
msgid ""
"It quickly becomes obvious when working with uniqueness types that having "
"only one reference at a time can be painful. For example, what if we want to"
" display a list before updating it?"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:148
msgid ""
"This is a valid definition of ``showU``, but unfortunately it consumes the "
"list! So the following function would be invalid:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:158
msgid ""
"Still, one would hope to be able to display a unique list without problem, "
"since it merely *inspects* the list; there are no updates. We can achieve "
"this, using the notion of *borrowing*. A Borrowed type is a Unique type "
"which can be inspected at the top level (by pattern matching, or by "
"*lending* to another function) but no further. This ensures that the "
"internals (i.e. the arguments to top level patterns) will not be passed to "
"any function which will update them."
msgstr ""

#: ..\..\reference\uniqueness-types.rst:166
msgid ""
"``Borrowed`` converts a ``UniqueType`` to a ``BorrowedType``. It is defined "
"as follows (along with some additional rules in the typechecker):"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:179
msgid ""
"A value can be \"lent\" to another function using ``lend``. Arguments to "
"``lend`` are not counted by the type checker as a reference to a unique "
"value, therefore a value can be lent as many times as desired. Using this, "
"we can write ``showU`` as follows:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:193
msgid ""
"Unlike a unique value, a borrowed value may be referred to as many times as "
"desired. However, there is a restriction on how a borrowed value can be "
"used. After all, much like a library book or your neighbour's lawnmower, if "
"a function borrows a value it is expected to return it in exactly the "
"condition in which it was received!"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:199
msgid ""
"The restriction is that when a ``Borrowed`` type is matched, any pattern "
"variables under the ``Read`` which have a unique type may not be referred to"
" at all on the right hand side (unless they are themselves ``lent`` to "
"another function)."
msgstr ""

#: ..\..\reference\uniqueness-types.rst:204
msgid ""
"Uniqueness information is stored in the type, and in particular in function "
"types. Once we're in a unique context, any new function which is constructed"
" will be required to have unique type, which prevents the following sort of "
"bad program being implemented:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:217
msgid ""
"Since ``lend`` is implicit, in practice for functions to lend and borrow "
"values merely requires the argument to be marked as ``Borrowed``. We can "
"therefore write ``showU`` as follows:"
msgstr ""

#: ..\..\reference\uniqueness-types.rst:231
msgid "Problems/Disadvantages/Still to do..."
msgstr ""

#: ..\..\reference\uniqueness-types.rst:233
msgid ""
"This is a work in progress, there is lots to do. The most obvious problem is"
" the loss of abstraction. On the one hand, we have more precise control over"
" memory usage with ``UniqueType`` and ``BorrowedType``, but they are not in "
"general compatible with functions polymorphic over ``Type``. In the short "
"term, we can start to write reactive and low memory systems with this, but "
"longer term it would be nice to support more abstraction."
msgstr ""

#: ..\..\reference\uniqueness-types.rst:241
msgid ""
"We also haven't checked any of the metatheory, so this could all be fatally "
"flawed! The implementation is based to a large extent on `Uniqueness Typing "
"Simplified <http://lambda-the-ultimate.org/node/2708>`__, by de Vries et al,"
" so there is reason to believe things should be fine, but we still have to "
"do the work."
msgstr ""

#: ..\..\reference\uniqueness-types.rst:248
msgid ""
"Much as there are with linear types, there are some annoyances when trying "
"to prove properties of functions with unique types (for example, what counts"
" as a use of a value). Since we require *at most* one use of a value, rather"
" than *exactly* one, this seems to be less of an issue in practice, but "
"still needs thought."
msgstr ""
