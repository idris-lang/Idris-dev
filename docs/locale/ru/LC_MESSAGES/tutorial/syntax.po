# 
msgid ""
msgstr ""
"Project-Id-Version: Idris 0.9.17\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-05-20 17:05+0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\tutorial\syntax.rst:5
msgid "Syntax Extensions"
msgstr ""

#: ..\..\tutorial\syntax.rst:7
msgid ""
"Idris supports the implementation of *Embedded Domain Specific Languages* "
"(EDSLs) in several ways [1]_. One way, as we have already seen, is through "
"extending ``do`` notation. Another important way is to allow extension of "
"the core syntax. In this section we describe two ways of extending the "
"syntax: ``syntax`` rules and ``dsl`` notation."
msgstr ""

#: ..\..\tutorial\syntax.rst:14
msgid "``syntax`` rules"
msgstr ""

#: ..\..\tutorial\syntax.rst:16
msgid ""
"We have seen ``if...then...else`` expressions, but these are not built in. "
"Instead, we can define a function in the prelude as follows (we have already"
" seen this function in Section :ref:`sect-lazy`):"
msgstr ""

#: ..\..\tutorial\syntax.rst:26
msgid "and then extend the core syntax with a ``syntax`` declaration:"
msgstr ""

#: ..\..\tutorial\syntax.rst:32
msgid ""
"The left hand side of a ``syntax`` declaration describes the syntax rule, "
"and the right hand side describes its expansion. The syntax rule itself "
"consists of:"
msgstr ""

#: ..\..\tutorial\syntax.rst:36
msgid ""
"**Keywords** — here, ``if``, ``then`` and ``else``, which must be valid "
"identifiers"
msgstr ""

#: ..\..\tutorial\syntax.rst:39
msgid ""
"**Non-terminals** — included in square brackets, ``[test]``, ``[t]`` and "
"``[e]`` here, which stand for arbitrary expressions. To avoid parsing "
"ambiguities, these expressions cannot use syntax extensions at the top level"
" (though they can be used in parentheses)."
msgstr ""

#: ..\..\tutorial\syntax.rst:44
msgid ""
"**Names** — included in braces, which stand for names which may be bound on "
"the right hand side."
msgstr ""

#: ..\..\tutorial\syntax.rst:47
msgid ""
"**Symbols** — included in quotations marks, e.g. ``:=``. This can also be "
"used to include reserved words in syntax rules, such as ``let`` or ``in``."
msgstr ""

#: ..\..\tutorial\syntax.rst:51
msgid ""
"The limitations on the form of a syntax rule are that it must include at "
"least one symbol or keyword, and there must be no repeated variables "
"standing for non-terminals. Any expression can be used, but if there are two"
" non-terminals in a row in a rule, only simple expressions may be used (that"
" is, variables, constants, or bracketed expressions). Rules can use "
"previously defined rules, but may not be recursive. The following syntax "
"extensions would therefore be valid:"
msgstr ""

#: ..\..\tutorial\syntax.rst:66
msgid ""
"Syntax macros can be further restricted to apply only in patterns (i.e., "
"only on the left hand side of a pattern match clause) or only in terms (i.e."
" everywhere but the left hand side of a pattern match clause) by being "
"marked as ``pattern`` or ``term`` syntax rules. For example, we might define"
" an interval as follows, with a static check that the lower bound is below "
"the upper bound using ``so``:"
msgstr ""

#: ..\..\tutorial\syntax.rst:79
msgid ""
"We can define a syntax which, in patterns, always matches ``oh`` for the "
"proof argument, and in terms requires a proof term to be provided:"
msgstr ""

#: ..\..\tutorial\syntax.rst:87
msgid ""
"In terms, the syntax ``[x...y]`` will generate a proof obligation "
"``bounds_lemma`` (possibly renamed)."
msgstr ""

#: ..\..\tutorial\syntax.rst:90
msgid ""
"Finally, syntax rules may be used to introduce alternative binding forms. "
"For example, a ``for`` loop binds a variable on each iteration:"
msgstr ""

#: ..\..\tutorial\syntax.rst:102
msgid ""
"Note that we have used the ``{x}`` form to state that ``x`` represents a "
"bound variable, substituted on the right hand side. We have also put ``in`` "
"in quotation marks since it is already a reserved word."
msgstr ""

#: ..\..\tutorial\syntax.rst:107
msgid "``dsl`` notation"
msgstr ""

#: ..\..\tutorial\syntax.rst:109
msgid ""
"The well-typed interpreter in Section :ref:`sect-interp` is a simple example"
" of a common programming pattern with dependent types. Namely: describe an "
"*object language* and its type system with dependent types to guarantee that"
" only well-typed programs can be represented, then program using that "
"representation. Using this approach we can, for example, write programs for "
"serialising binary data [2]_ or running concurrent processes safely [3]_."
msgstr ""

#: ..\..\tutorial\syntax.rst:117
msgid ""
"Unfortunately, the form of object language programs makes it rather hard to "
"program this way in practice. Recall the factorial program in ``Expr`` for "
"example:"
msgstr ""

#: ..\..\tutorial\syntax.rst:128
msgid ""
"Since this is a particularly useful pattern, Idris provides syntax "
"overloading [1]_ to make it easier to program in such object languages:"
msgstr ""

#: ..\..\tutorial\syntax.rst:143
msgid ""
"A ``dsl`` block describes how each syntactic construct is represented in an "
"object language. Here, in the ``expr`` language, any variable is translated "
"to the ``Var`` constructor, using ``Pop`` and ``Stop`` to construct the de "
"Bruijn index (i.e., to count how many bindings since the variable itself was"
" bound); and any lambda is translated to a ``Lam`` constructor. The "
"``mkLam`` function simply ignores its first argument, which is the name that"
" the user chose for the variable. It is also possible to overload ``let`` "
"and dependent function syntax (``pi``) in this way. We can now write "
"``fact`` as follows:"
msgstr ""

#: ..\..\tutorial\syntax.rst:159
msgid ""
"In this new version, ``expr`` declares that the next expression will be "
"overloaded. We can take this further, using idiom brackets, by declaring:"
msgstr ""

#: ..\..\tutorial\syntax.rst:171
msgid ""
"Note that there is no need for these to be part of an instance of "
"``Applicative``, since idiom bracket notation translates directly to the "
"names ``<*>`` and ``pure``, and ad-hoc type-directed overloading is allowed."
" We can now say:"
msgstr ""

#: ..\..\tutorial\syntax.rst:182
msgid ""
"With some more ad-hoc overloading and type class instances, and a new syntax"
" rule, we can even go as far as:"
msgstr ""

#: ..\..\tutorial\syntax.rst:193
msgid ""
"Edwin Brady and Kevin Hammond. 2012. Resource-Safe systems programming with "
"embedded domain specific languages. In Proceedings of the 14th international"
" conference on Practical Aspects of Declarative Languages (PADL'12), Claudio"
" Russo and Neng-Fa Zhou (Eds.). Springer-Verlag, Berlin, Heidelberg, "
"242-257. DOI=10.1007/978-3-642-27694-1_18 "
"http://dx.doi.org/10.1007/978-3-642-27694-1_18"
msgstr ""

#: ..\..\tutorial\syntax.rst:201
msgid ""
"Edwin C. Brady. 2011. IDRIS ---: systems programming meets full dependent "
"types. In Proceedings of the 5th ACM workshop on Programming languages meets"
" program verification (PLPV '11). ACM, New York, NY, USA, 43-54. "
"DOI=10.1145/1929529.1929536 http://doi.acm.org/10.1145/1929529.1929536"
msgstr ""

#: ..\..\tutorial\syntax.rst:208
msgid ""
"Edwin Brady and Kevin Hammond. 2010. Correct-by-Construction Concurrency: "
"Using Dependent Types to Verify Implementations of Effectful Resource Usage "
"Protocols. Fundam. Inf. 102, 2 (April 2010), 145-176. "
"http://dl.acm.org/citation.cfm?id=1883636"
msgstr ""
