# 
msgid ""
msgstr ""
"Project-Id-Version: Idris 0.9.17\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-05-20 17:05+0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\tutorial\theorems.rst:5
msgid "Theorem Proving"
msgstr ""

#: ..\..\tutorial\theorems.rst:8
msgid "Equality"
msgstr ""

#: ..\..\tutorial\theorems.rst:10
msgid ""
"Idris allows propositional equalities to be declared, allowing theorems "
"about programs to be stated and proved. Equality is built in, but "
"conceptually has the following definition:"
msgstr ""

#: ..\..\tutorial\theorems.rst:19
msgid ""
"Equalities can be proposed between any values of any types, but the only way"
" to construct a proof of equality is if values actually are equal. For "
"example:"
msgstr ""

#: ..\..\tutorial\theorems.rst:34
msgid "The Empty Type"
msgstr ""

#: ..\..\tutorial\theorems.rst:36
msgid ""
"There is an empty type, :math:`\\bot`, which has no constructors. It is "
"therefore impossible to construct an element of the empty type, at least "
"without using a partially defined or general recursive function (see Section"
" :ref:`sect-totality` for more details). We can therefore use the empty type"
" to prove that something is impossible, for example zero is never equal to a"
" successor:"
msgstr ""

#: ..\..\tutorial\theorems.rst:52
msgid ""
"There is no need to worry too much about how this function works — "
"essentially, it applies the library function ``replace``, which uses an "
"equality proof to transform a predicate. Here we use it to transform a value"
" of a type which can exist, the empty tuple, to a value of a type which "
"can’t, by using a proof of something which can’t exist."
msgstr ""

#: ..\..\tutorial\theorems.rst:58
msgid ""
"Once we have an element of the empty type, we can prove anything. ``void`` "
"is defined in the library, to assist with proofs by contradiction."
msgstr ""

#: ..\..\tutorial\theorems.rst:67
msgid "Simple Theorems"
msgstr ""

#: ..\..\tutorial\theorems.rst:69
msgid ""
"When type checking dependent types, the type itself gets *normalised*. So "
"imagine we want to prove the following theorem about the reduction behaviour"
" of ``plus``:"
msgstr ""

#: ..\..\tutorial\theorems.rst:77
msgid ""
"We’ve written down the statement of the theorem as a type, in just the same "
"way as we would write the type of a program. In fact there is no real "
"distinction between proofs and programs. A proof, as far as we are concerned"
" here, is merely a program with a precise enough type to guarantee a "
"particular property of interest."
msgstr ""

#: ..\..\tutorial\theorems.rst:83
msgid ""
"We won’t go into details here, but the Curry-Howard correspondence [1]_ "
"explains this relationship. The proof itself is trivial, because ``plus Z "
"n`` normalises to ``n`` by the definition of ``plus``:"
msgstr ""

#: ..\..\tutorial\theorems.rst:91
msgid ""
"It is slightly harder if we try the arguments the other way, because plus is"
" defined by recursion on its first argument. The proof also works by "
"recursion on the first argument to ``plus``, namely ``n``."
msgstr ""

#: ..\..\tutorial\theorems.rst:101
msgid ""
"``cong`` is a function defined in the library which states that equality "
"respects function application:"
msgstr ""

#: ..\..\tutorial\theorems.rst:108
msgid "We can do the same for the reduction behaviour of plus on successors:"
msgstr ""

#: ..\..\tutorial\theorems.rst:116
msgid ""
"Even for trival theorems like these, the proofs are a little tricky to "
"construct in one go. When things get even slightly more complicated, it "
"becomes too much to think about to construct proofs in this ‘batch mode’."
msgstr ""

#: ..\..\tutorial\theorems.rst:121
msgid ""
"Idris provides interactive editing capabilities, which can help with "
"building proofs. For more details on building proofs interactively in an "
"editor, see :ref:`proofs-index`."
msgstr ""

#: ..\..\tutorial\theorems.rst:128
msgid "Totality Checking"
msgstr ""

#: ..\..\tutorial\theorems.rst:130
msgid ""
"If we really want to trust our proofs, it is important that they are defined"
" by *total* functions — that is, a function which is defined for all "
"possible inputs and is guaranteed to terminate. Otherwise we could construct"
" an element of the empty type, from which we could prove anything:"
msgstr ""

#: ..\..\tutorial\theorems.rst:148
msgid ""
"Internally, Idris checks every definition for totality, and we can check at "
"the prompt with the ``:total`` command. We see that neither of the above "
"definitions is total:"
msgstr ""

#: ..\..\tutorial\theorems.rst:160
msgid ""
"Note the use of the word “possibly” — a totality check can, of course, never"
" be certain due to the undecidability of the halting problem. The check is, "
"therefore, conservative. It is also possible (and indeed advisable, in the "
"case of proofs) to mark functions as total so that it will be a compile time"
" error for the totality check to fail:"
msgstr ""

#: ..\..\tutorial\theorems.rst:176
msgid ""
"Reassuringly, our proof in Section :ref:`sect-empty` that the zero and "
"successor constructors are disjoint is total:"
msgstr ""

#: ..\..\tutorial\theorems.rst:184
msgid ""
"The totality check is, necessarily, conservative. To be recorded as total, a"
" function ``f`` must:"
msgstr ""

#: ..\..\tutorial\theorems.rst:187
msgid "Cover all possible inputs"
msgstr ""

#: ..\..\tutorial\theorems.rst:189
msgid ""
"Be *well-founded* — i.e. by the time a sequence of (possibly mutually) "
"recursive calls reaches ``f`` again, it must be possible to show that one of"
" its arguments has decreased."
msgstr ""

#: ..\..\tutorial\theorems.rst:193
msgid "Not use any data types which are not *strictly positive*"
msgstr ""

#: ..\..\tutorial\theorems.rst:195
msgid "Not call any non-total functions"
msgstr ""

#: ..\..\tutorial\theorems.rst:198
msgid "Directives and Compiler Flags for Totality"
msgstr ""

#: ..\..\tutorial\theorems.rst:200
msgid ""
"By default, Idris allows all well-typed definitions, whether total or not. "
"However, it is desirable for functions to be total as far as possible, as "
"this provides a guarantee that they provide a result for all possible "
"inputs, in finite time. It is possible to make total functions a "
"requirement, either:"
msgstr ""

#: ..\..\tutorial\theorems.rst:205
msgid "By using the ``--total`` compiler flag."
msgstr ""

#: ..\..\tutorial\theorems.rst:207
msgid ""
"By adding a ``%default total`` directive to a source file. All definitions "
"after this will be required to be total, unless explicitly flagged as "
"``partial``."
msgstr ""

#: ..\..\tutorial\theorems.rst:211
msgid ""
"All functions *after* a ``%default total`` declaration are required to be "
"total. Correspondingly, after a ``%default partial`` declaration, the "
"requirement is relaxed."
msgstr ""

#: ..\..\tutorial\theorems.rst:215
msgid ""
"Finally, the compiler flag ``--warnpartial`` causes to print a warning for "
"any undeclared partial function."
msgstr ""

#: ..\..\tutorial\theorems.rst:219
msgid "Totality checking issues"
msgstr ""

#: ..\..\tutorial\theorems.rst:221
msgid ""
"Please note that the totality checker is not perfect! Firstly, it is "
"necessarily conservative due to the undecidability of the halting problem, "
"so many programs which *are* total will not be detected as such. Secondly, "
"the current implementation has had limited effort put into it so far, so "
"there may still be cases where it believes a function is total which is not."
" Do not rely on it for your proofs yet!"
msgstr ""

#: ..\..\tutorial\theorems.rst:229
msgid "Hints for totality"
msgstr ""

#: ..\..\tutorial\theorems.rst:231
msgid ""
"In cases where you believe a program is total, but Idris does not agree, it "
"is possible to give hints to the checker to give more detail for a "
"termination argument. The checker works by ensuring that all chains of "
"recursive calls eventually lead to one of the arguments decreasing towards a"
" base case, but sometimes this is hard to spot. For example, the following "
"definition cannot be checked as ``total`` because the checker cannot decide "
"that ``filter (<= x) xs`` will always be smaller than ``(x :: xs)``:"
msgstr ""

#: ..\..\tutorial\theorems.rst:247
msgid ""
"The function ``assert_smaller``, defined in the Prelude, is intended to "
"address this problem:"
msgstr ""

#: ..\..\tutorial\theorems.rst:255
msgid ""
"It simply evaluates to its second argument, but also asserts to the totality"
" checker that ``y`` is structurally smaller than ``x``. This can be used to "
"explain the reasoning for totality if the checker cannot work it out itself."
" The above example can now be written as:"
msgstr ""

#: ..\..\tutorial\theorems.rst:269
msgid ""
"The expression ``assert_smaller (x :: xs) (filter (<= x) xs)`` asserts that "
"the result of the filter will always be smaller than the pattern ``(x :: "
"xs)``."
msgstr ""

#: ..\..\tutorial\theorems.rst:273
msgid ""
"In more extreme cases, the function ``assert_total`` marks a subexpression "
"as always being total:"
msgstr ""

#: ..\..\tutorial\theorems.rst:281
msgid ""
"In general, this function should be avoided, but it can be very useful when "
"reasoning about primitives or externally defined functions (for example from"
" a C library) where totality can be shown by an external argument."
msgstr ""

#: ..\..\tutorial\theorems.rst:287
msgid ""
"Timothy G. Griffin. 1989. A formulae-as-type notion of control. In "
"Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of "
"programming languages (POPL '90). ACM, New York, NY, USA, 47-58. "
"DOI=10.1145/96709.96714 http://doi.acm.org/10.1145/96709.96714"
msgstr ""
