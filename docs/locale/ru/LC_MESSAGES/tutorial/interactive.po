# 
msgid ""
msgstr ""
"Project-Id-Version: Idris 0.9.17\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-05-20 17:05+0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\tutorial\interactive.rst:5
msgid "Interactive Editing"
msgstr ""

#: ..\..\tutorial\interactive.rst:7
msgid ""
"By now, we have seen several examples of how Idris’ dependent type system "
"can give extra confidence in a function’s correctness by giving a more "
"precise description of its intended behaviour in its *type*. We have also "
"seen an example of how the type system can help with EDSL development by "
"allowing a programmer to describe the type system of an object language. "
"However, precise types give us more than verification of programs — we can "
"also exploit types to help write programs which are *correct by "
"construction*."
msgstr ""

#: ..\..\tutorial\interactive.rst:16
msgid ""
"The Idris REPL provides several commands for inspecting and modifying parts "
"of programs, based on their types, such as case splitting on a pattern "
"variable, inspecting the type of a metavariable, and even a basic proof "
"search mechanism. In this section, we explain how these features can be "
"exploited by a text editor, and specifically how to do so in `Vim "
"<https://github.com/idris-hackers/idris-vim>`_. An interactive mode for "
"`Emacs <https://github.com/idris-hackers/idris-emacs>`_ is also available."
msgstr ""

#: ..\..\tutorial\interactive.rst:28
msgid "Editing at the REPL"
msgstr ""

#: ..\..\tutorial\interactive.rst:30
msgid ""
"The REPL provides a number of commands, which we will describe shortly, "
"which generate new program fragments based on the currently loaded module. "
"These take the general form"
msgstr ""

#: ..\..\tutorial\interactive.rst:38
msgid ""
"That is, each command acts on a specific source line, at a specific name, "
"and outputs a new program fragment. Each command has an alternative form, "
"which *updates* the source file in-place:"
msgstr ""

#: ..\..\tutorial\interactive.rst:46
msgid ""
"When the REPL is loaded, it also starts a background process which accepts "
"and responds to REPL commands, using ``idris --client``. For example, if we "
"have a REPL running elsewhere, we can execute commands such as:"
msgstr ""

#: ..\..\tutorial\interactive.rst:58
msgid ""
"A text editor can take advantage of this, along with the editing commands, "
"in order to provide interactive editing support."
msgstr ""

#: ..\..\tutorial\interactive.rst:62
msgid "Editing Commands"
msgstr ""

#: ..\..\tutorial\interactive.rst:65
msgid ":addclause"
msgstr ""

#: ..\..\tutorial\interactive.rst:67
msgid ""
"The ``:addclause n f`` command (abbreviated ``:ac n f``) creates a template "
"definition for the function named ``f`` declared on line ``n``.  For "
"example, if the code beginning on line 94 contains:"
msgstr ""

#: ..\..\tutorial\interactive.rst:76
msgid "then ``:ac 94 vzipWith`` will give:"
msgstr ""

#: ..\..\tutorial\interactive.rst:82
msgid ""
"The names are chosen according to hints which may be given by a programmer, "
"and then made unique by the machine by adding a digit if necessary. Hints "
"can be given as follows:"
msgstr ""

#: ..\..\tutorial\interactive.rst:90
msgid ""
"This declares that any names generated for types in the ``Vect`` family "
"should be chosen in the order ``xs``, ``ys``, ``zs``, ``ws``."
msgstr ""

#: ..\..\tutorial\interactive.rst:94
msgid ":casesplit"
msgstr ""

#: ..\..\tutorial\interactive.rst:96
msgid ""
"The ``:casesplit n x`` command, abbreviated ``:cs n x``, splits the pattern "
"variable ``x`` on line ``n`` into the various pattern forms it may take, "
"removing any cases which are impossible due to unification errors. For "
"example, if the code beginning on line 94 is:"
msgstr ""

#: ..\..\tutorial\interactive.rst:107
msgid "then ``:cs 96 xs`` will give:"
msgstr ""

#: ..\..\tutorial\interactive.rst:114
msgid ""
"That is, the pattern variable ``xs`` has been split into the two possible "
"cases ``[]`` and ``x :: xs``. Again, the names are chosen according to the "
"same heuristic. If we update the file (using ``:cs!``) then case split on "
"``ys`` on the same line, we get:"
msgstr ""

#: ..\..\tutorial\interactive.rst:123
msgid ""
"That is, the pattern variable ``ys`` has been split into one case ``[]``, "
"Idris having noticed that the other possible case ``y :: ys`` would lead to "
"a unification error."
msgstr ""

#: ..\..\tutorial\interactive.rst:128
msgid ":addmissing"
msgstr ""

#: ..\..\tutorial\interactive.rst:130
msgid ""
"The ``:addmissing n f`` command, abbreviated ``:am n f``, adds the clauses "
"which are required to make the function ``f`` on line ``n`` cover all "
"inputs. For example, if the code beginning on line 94 is"
msgstr ""

#: ..\..\tutorial\interactive.rst:140
msgid "then ``:am 96 vzipWith`` gives:"
msgstr ""

#: ..\..\tutorial\interactive.rst:146
msgid ""
"That is, it notices that there are no cases for non-empty vectors, generates"
" the required clauses, and eliminates the clauses which would lead to "
"unification errors."
msgstr ""

#: ..\..\tutorial\interactive.rst:151
msgid ":proofsearch"
msgstr ""

#: ..\..\tutorial\interactive.rst:153
msgid ""
"The ``:proofsearch n f`` command, abbreviated ``:ps n f``, attempts to find "
"a value for the metavariable ``f`` on line ``n`` by proof search, trying "
"values of local variables, recursive calls and constructors of the required "
"family. Optionally, it can take a list of *hints*, which are functions it "
"can try applying to solve the metavariable. For example, if the code "
"beginning on line 94 is:"
msgstr ""

#: ..\..\tutorial\interactive.rst:167
msgid "then ``:ps 96 vzipWith_rhs_1`` will give"
msgstr ""

#: ..\..\tutorial\interactive.rst:173
msgid ""
"This works because it is searching for a ``Vect`` of length 0, of which the "
"empty vector is the only possibiliy. Similarly, and perhaps surprisingly, "
"there is only one possibility if we try to solve ``:ps 97 vzipWith_rhs_2``:"
msgstr ""

#: ..\..\tutorial\interactive.rst:182
msgid ""
"This works because ``vzipWith`` has a precise enough type: The resulting "
"vector has to be non-empty (a ``::``); the first element must have type "
"``c`` and the only way to get this is to apply ``f`` to ``x`` and ``y``; "
"finally, the tail of the vector can only be built recursively."
msgstr ""

#: ..\..\tutorial\interactive.rst:189
msgid ":makewith"
msgstr ""

#: ..\..\tutorial\interactive.rst:191
msgid ""
"The ``:makewith n f`` command, abbreviated ``:mw n f``, adds a ``with`` to a"
" pattern clause. For example, recall ``parity``. If line 10 is:"
msgstr ""

#: ..\..\tutorial\interactive.rst:199
msgid "then ``:mw 10 parity`` will give:"
msgstr ""

#: ..\..\tutorial\interactive.rst:206
msgid ""
"If we then fill in the placeholder ``_`` with ``parity k`` and case split on"
" ``with_pat`` using ``:cs 11 with_pat`` we get the following patterns:"
msgstr ""

#: ..\..\tutorial\interactive.rst:215
msgid ""
"Note that case splitting has normalised the patterns here (giving ``plus`` "
"rather than ``+``). In any case, we see that using interactive editing "
"significantly simplifies the implementation of dependent pattern matching by"
" showing a programmer exactly what the valid patterns are."
msgstr ""

#: ..\..\tutorial\interactive.rst:222
msgid "Interactive Editing in Vim"
msgstr ""

#: ..\..\tutorial\interactive.rst:224
msgid ""
"The editor mode for Vim provides syntax highlighting, indentation and "
"interactive editing support using the commands described above. Interactive "
"editing is achieved using the following editor commands, each of which "
"update the buffer directly:"
msgstr ""

#: ..\..\tutorial\interactive.rst:230
msgid "``\\d`` adds a template definition for the name declared on the"
msgstr ""

#: ..\..\tutorial\interactive.rst:230
msgid "current line (using ``:addclause``)."
msgstr ""

#: ..\..\tutorial\interactive.rst:233
msgid "``\\c`` case splits the variable at the cursor (using"
msgstr ""

#: ..\..\tutorial\interactive.rst:233
msgid "``:casesplit``)."
msgstr ""

#: ..\..\tutorial\interactive.rst:236
msgid "``\\m`` adds the missing cases for the name at the cursor (using"
msgstr ""

#: ..\..\tutorial\interactive.rst:236
msgid "``:addmissing``)."
msgstr ""

#: ..\..\tutorial\interactive.rst:238
msgid "``\\w`` adds a ``with`` clause (using ``:makewith``)."
msgstr ""

#: ..\..\tutorial\interactive.rst:241
msgid "``\\o`` invokes a proof search to solve the metavariable under the"
msgstr ""

#: ..\..\tutorial\interactive.rst:241
msgid "cursor (using ``:proofsearch``)."
msgstr ""

#: ..\..\tutorial\interactive.rst:244
msgid "``\\p`` invokes a proof search with additional hints to solve the"
msgstr ""

#: ..\..\tutorial\interactive.rst:244
msgid "metavariable under the cursor (using ``:proofsearch``)."
msgstr ""

#: ..\..\tutorial\interactive.rst:246
msgid "There are also commands to invoke the type checker and evaluator:"
msgstr ""

#: ..\..\tutorial\interactive.rst:250
msgid "``\\t`` displays the type of the (globally visible) name under the"
msgstr ""

#: ..\..\tutorial\interactive.rst:249
msgid ""
"cursor. In the case of a metavariable, this displays the context and the "
"expected type."
msgstr ""

#: ..\..\tutorial\interactive.rst:252
msgid "``\\e`` prompts for an expression to evaluate."
msgstr ""

#: ..\..\tutorial\interactive.rst:254
msgid "``\\r`` reloads and type checks the buffer."
msgstr ""

#: ..\..\tutorial\interactive.rst:256
msgid ""
"Corresponding commands are also available in the Emacs mode. Support for "
"other editors can be added in a relatively straighforward manner by using "
"``idris –client``."
msgstr ""
