# 
msgid ""
msgstr ""
"Project-Id-Version: Idris 0.9.17\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-05-20 17:05+0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\tutorial\modules.rst:5
msgid "Modules and Namespaces"
msgstr ""

#: ..\..\tutorial\modules.rst:7
msgid ""
"An Idris program consists of a collection of modules. Each module includes "
"an optional ``module`` declaration giving the name of the module, a list of "
"``import`` statements giving the other modules which are to be imported, and"
" a collection of declarations and definitions of types, classes and "
"functions. For example, the listing below gives a module which defines a "
"binary tree type ``BTree`` (in a file ``Btree.idr``):"
msgstr ""

#: ..\..\tutorial\modules.rst:36
msgid ""
"Then, this gives a main program (in a file ``bmain.idr``) which uses the "
"``bst`` module to sort a list:"
msgstr ""

#: ..\..\tutorial\modules.rst:51
msgid ""
"The same names can be defined in multiple modules. This is possible because "
"in practice names are *qualified* with the name of the module. The names "
"defined in the ``btree`` module are, in full:"
msgstr ""

#: ..\..\tutorial\modules.rst:55
msgid "``Btree.BTree``"
msgstr ""

#: ..\..\tutorial\modules.rst:56
msgid "``Btree.Leaf``"
msgstr ""

#: ..\..\tutorial\modules.rst:57
msgid "``Btree.Node``"
msgstr ""

#: ..\..\tutorial\modules.rst:58
msgid "``Btree.insert``"
msgstr ""

#: ..\..\tutorial\modules.rst:59
msgid "``Btree.toList``"
msgstr ""

#: ..\..\tutorial\modules.rst:60
msgid "``Btree.toTree``"
msgstr ""

#: ..\..\tutorial\modules.rst:62
msgid ""
"If names are otherwise unambiguous, there is no need to give the fully "
"qualified name. Names can be disambiguated either by giving an explicit "
"qualification, or according to their type."
msgstr ""

#: ..\..\tutorial\modules.rst:66
msgid ""
"There is no formal link between the module name and its filename, although "
"it is generally advisable to use the same name for each. An ``import`` "
"statement refers to a filename, using dots to separate directories. For "
"example, ``import foo.bar`` would import the file ``foo/bar.idr``, which "
"would conventionally have the module declaration ``module foo.bar``. The "
"only requirement for module names is that the main module, with the ``main``"
" function, must be called ``Main``â€”although its filename need not be "
"``Main.idr``."
msgstr ""

#: ..\..\tutorial\modules.rst:76
msgid "Export Modifiers"
msgstr ""

#: ..\..\tutorial\modules.rst:78
msgid ""
"By default, all names defined in a module are exported for use by other "
"modules. However, it is good practice only to export a minimal interface and"
" keep internal details abstract. Idris allows functions, types, and classes "
"to be marked as: ``public``, ``abstract`` or ``private``:"
msgstr ""

#: ..\..\tutorial\modules.rst:83
msgid ""
"``public`` means that both the name and definition are exported. For "
"functions, this means that the implementation is exported (which means, for "
"example, it can be used in a dependent type). For data types, this means "
"that the type name and the constructors are exported. For classes, this "
"means that the class name and method names are exported."
msgstr ""

#: ..\..\tutorial\modules.rst:90
msgid ""
"``abstract`` means that only the name is exported. For functions, this means"
" that the implementation is not exported. For data types, this means that "
"the type name is exported but not the constructors. For classes, this means "
"that the class name is exported but not the method names."
msgstr ""

#: ..\..\tutorial\modules.rst:96
msgid ""
"``private`` means that neither the name nor the definition is exported."
msgstr ""

#: ..\..\tutorial\modules.rst:100
msgid ""
"If any definition is given an export modifier, then all names with no "
"modifier are assumed to be ``private``."
msgstr ""

#: ..\..\tutorial\modules.rst:102
msgid ""
"For our ``btree`` module, it makes sense for the tree data type and the "
"functions to be exported as ``abstract``, as we see below:"
msgstr ""

#: ..\..\tutorial\modules.rst:128
msgid ""
"Finally, the default export mode can be changed with the ``%access`` "
"directive, for example:"
msgstr ""

#: ..\..\tutorial\modules.rst:153
msgid ""
"In this case, any function with no access modifier will be exported as "
"``abstract``, rather than left ``private``."
msgstr ""

#: ..\..\tutorial\modules.rst:156
msgid ""
"Additionally, a module can re-export a module it has imported, by using the "
"``public`` modifier on an ``import``. For example:"
msgstr ""

#: ..\..\tutorial\modules.rst:168
msgid ""
"The module ``A`` will export the name ``a``, as well as any public or "
"abstract names in module ``C``, but will not re-export anything from module "
"``B``."
msgstr ""

#: ..\..\tutorial\modules.rst:173
msgid "Explicit Namespaces"
msgstr ""

#: ..\..\tutorial\modules.rst:175
msgid ""
"Defining a module also defines a namespace implicitly. However, namespaces "
"can also be given *explicitly*. This is most useful if you wish to overload "
"names within the same module:"
msgstr ""

#: ..\..\tutorial\modules.rst:191
msgid ""
"This (admittedly contrived) module defines two functions with fully "
"qualified names ``foo.x.test`` and ``foo.y.test``, which can be "
"disambiguated by their types:"
msgstr ""

#: ..\..\tutorial\modules.rst:203
msgid "Parameterised blocks"
msgstr ""

#: ..\..\tutorial\modules.rst:205
msgid ""
"Groups of functions can be parameterised over a number of arguments using a "
"``parameters`` declaration, for example:"
msgstr ""

#: ..\..\tutorial\modules.rst:214
msgid ""
"The effect of a ``parameters`` block is to add the declared parameters to "
"every function, type and data constructor within the block. Outside the "
"block, the parameters must be given explicitly:"
msgstr ""

#: ..\..\tutorial\modules.rst:223
msgid ""
"Parameters blocks can be nested, and can also include data declarations, in "
"which case the parameters are added explicitly to all type and data "
"constructors. They may also be dependent types with implicit arguments:"
msgstr ""

#: ..\..\tutorial\modules.rst:236
msgid ""
"To use ``Vects`` or ``append`` outside the block, we must also give the "
"``xs`` and ``y`` arguments. Here, we can use placeholders for the values "
"which can be inferred by the type checker:"
msgstr ""
