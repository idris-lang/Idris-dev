# 
msgid ""
msgstr ""
"Project-Id-Version: Idris 0.9.17\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-05-20 17:05+0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\guides\type-providers-ffi.rst:3
msgid "Type Providers in Idris"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:5
msgid ""
"`Type providers in Idris <http://www.itu.dk/people/drc/pubs/dependent-type-"
"providers.pdf>`__ are simple enough, but there are a few caveats to using "
"them that it would be worthwhile to go through the basic steps. We also go "
"over foreign functions, because these will often be used with type "
"providers."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:13
msgid "The use case"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:15
msgid ""
"First, let's talk about *why* we might want type providers. There are a "
"number of reasons to use them and there are other examples available around "
"the net, but in this tutorial we'll be using them to port C's ``struct "
"stat`` to Idris."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:20
msgid ""
"Why do we need type providers? Well, Idris's FFI needs to know the types of "
"the things it passes to and from C, but the fields of a ``struct stat`` are "
"implementation-dependent types that cannot be relied upon. We don't just "
"want to hard-code these types into our program... so we'll use a type "
"provider to find them at compile time!"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:27
msgid "A simple example"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:29
msgid ""
"First, let's go over a basic usage of type providers, because foreign "
"functions can be confusing but it's important to remember that providers "
"themselves are simple."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:33
msgid ""
"A type provider is simply an IO action that returns a value of this type:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:40
msgid ""
"Looks familiar? ``Provider`` is just ``Either a String``, given a slightly "
"more descriptive name."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:43
msgid ""
"Remember though, type providers we use in our program must be IO actions. "
"Let's write a simple one now:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:60
msgid ""
"We assume that whoever's compiling the library knows the size of ``size_t``,"
" so we'll just ask them! (Don't worry, we'll get it ourselves later.) Then, "
"if their response can be converted to an integer, we present ``Provide "
"sizeTSize`` as the result of our IO action; or if it can't, we signal a "
"failure. (This will then become a compile-time error.)"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:67
msgid "Now we can use this IO action as a type provider:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:90
msgid ""
"Yay! We... asked the user something at compile time? That's not very good, "
"actually. Our library is going to be difficult to compile! This is hardly a "
"step up from having them edit in the size of ``size_t`` themselves!"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:95
msgid "Don't worry, there's a better way."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:98
msgid "Foreign Functions"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:100
msgid ""
"It's actually pretty easy to write a C function that figures out the size of"
" ``size_t``:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:107
msgid ""
"(Why an int and not a ``size_t``? The FFI needs to know how to receive the "
"return value of this function and translate it into an Idris value. If we "
"knew how to do this for values of C type ``size_t``, we wouldn't need to "
"write this function at all! If we really wanted to be safe from overflow, we"
" could use an array of multiple integers, but the SIZE of ``size_t`` is "
"never going to be a 65535 byte integer.)"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:114
msgid ""
"So now we can get the size of ``size_t`` as long as we're in C code. We'd "
"like to be able to use this from Idris. Can we do this? It turns out we can."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:119
msgid "``mkForeign``"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:121
msgid ""
"With mkForeign, we can turn a C function into an IO action. It works like "
"this:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:129
msgid ""
"Pretty simple. ``mkForeign`` takes a specification of what function it needs"
" to call, and we construct this specification with ``FFun``. And ``FFun`` "
"just takes a name, a list of argument types (we have none), and a return "
"type."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:134
msgid ""
"One thing you might want to note: the return type we've specified is "
"``FInt``, not ``Int``. That's because ``Int`` is an idris type and C "
"functions don't return idris types. ``FInt`` is not an idris type, but is "
"just the representation of the type of a C int. It tells the compiler "
"\"Treat the return value of this C function like it's a C int, and when you "
"pass it back into Idris, convert it to an Idris int.\""
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:142
msgid "Caveats of mkForeign"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:144
msgid ""
"First and foremost: ``mkForeign`` is not actually a function. It is treated "
"specially by the compiler, and there are certain rules you need to follow "
"when using it."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:148
msgid "Rule 1: the name string must be a literal or constant"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:150
msgid "This does not work:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:157
msgid ""
"You'll just have to bite the bullet and write out the whole ``mkForeign`` "
"and ``FFun`` expression each time."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:160
msgid "Rule 2: the \"call\" to ``mkForeign`` must be fully applied"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:162
msgid ""
"This just means that every argument appearing in the list of argument types "
"must be applied wherever you write ``mkForeign``. The arguments don't have "
"to be literals or even known at compile time; they just have to be there. "
"For example, if we have ``strlen : String -> IO Int``, then this is fine:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:172
msgid "but this is not fine:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:178
msgid ""
"Note that this only applies to places where you literally typed "
"``mkForeign``. Once you've defined it, ``strlen`` is just a normal function "
"returning an IO action, and it doesn't need to be fully applied. This is "
"okay:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:189
msgid "Running foreign functions"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:191
msgid ""
"This is all well and good for writing code that will typecheck. To actually "
"run the code, we'll need to do just a bit more work. Exactly what we need to"
" do depends on whether we want to interpret or compile our code."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:197
msgid "In the interpreter"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:199
msgid ""
"If we want to call our foreign functions from interpreted code (such as the "
"REPL or a type provider), we need to dynamically link a library containing "
"the symbols we need. This is pretty easy to do with the ``%dynamic`` "
"directive:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:208
msgid ""
"Note that the leading \"./\" is important: currently, the string you provide"
" is interpreted as by ``dlopen()``, which on Unix does not search in the "
"current directory by default. If you use the \"./\", the library will be "
"searched for in the directory from which you run idris (*not* the location "
"of the file you're running!). Of course, if you're using functions from an "
"installed library rather than something you wrote yourself, the \"./\" is "
"not necessary."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:217
msgid "In an executable"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:219
msgid ""
"If we want to run our code from an executable, we can statically link "
"instead. We'll use the ``%include`` and ``%link`` directives:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:227
msgid ""
"Note the extra argument to the directive! We specify that we're linking a C "
"header and library. Also, unlike ``%dynamic``, these directives search in "
"the current directory by default. (That is, the directory from which we run "
"idris.)"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:233
msgid "Putting it all together"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:235
msgid ""
"So, at the beginning of this article I said we'd use type providers to port "
"``struct stat`` to Idris. The relevant part is just translating all the "
"mysterious typedef'd C types into Idris types, and that's what we'll do "
"here."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:240
msgid "First, let's write a C file containing functions that we'll bind to."
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:249
msgid "Next, an Idris file to define our providers:"
msgstr ""

#: ..\..\guides\type-providers-ffi.rst:276
msgid ""
"Finally, we'll write one more idris file where we use the type providers:"
msgstr ""
