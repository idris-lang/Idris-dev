# 
msgid ""
msgstr ""
"Project-Id-Version: Idris 0.9.17\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-05-20 17:05+0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\effects\depeff.rst:5
msgid "Dependent Effects"
msgstr ""

#: ..\..\effects\depeff.rst:7
msgid ""
"In the programs we have seen so far, the available effects have remained "
"constant. Sometimes, however, an operation can *change* the available "
"effects. The simplest example occurs when we have a state with a dependent "
"type—adding an element to a vector also changes its type, for example, since"
" its length is explicit in the type. In this section, we will see how the "
"library supports this. Firstly, we will see how states with dependent types "
"can be implemented. Secondly, we will see how the effects can depend on the "
"*result* of an effectful operation. Finally, we will see how this can be "
"used to implement a type-safe and resource-safe protocol for file "
"management."
msgstr ""

#: ..\..\effects\depeff.rst:19
msgid "Dependent States"
msgstr ""

#: ..\..\effects\depeff.rst:21
msgid ""
"Suppose we have a function which reads input from the console, converts it "
"to an integer, and adds it to a list which is stored in a ``STATE``. It "
"might look something like the following:"
msgstr ""

#: ..\..\effects\depeff.rst:31
msgid ""
"But what if, instead of a list of integers, we would like to store a "
"``Vect``, maintaining the length in the type?"
msgstr ""

#: ..\..\effects\depeff.rst:40
msgid ""
"This will not type check! Although the vector has length ``n`` on entry to "
"``readInt``, it has length ``S n`` on exit. The library allows us to express"
" this as follows:"
msgstr ""

#: ..\..\effects\depeff.rst:51
msgid ""
"The notation ``{ xs ==> xs’ } Eff a`` in a type means that the operation "
"begins with effects ``xs`` available, and ends with effects ``xs’`` "
"available. We have used ``putM`` to update the state, where the ``M`` suffix"
" indicates that the *type* is being updated as well as the value. It has the"
" following type:"
msgstr ""

#: ..\..\effects\depeff.rst:62
msgid "Result-dependent Effects"
msgstr ""

#: ..\..\effects\depeff.rst:64
msgid ""
"Often, whether a state is updated could depend on the success or otherwise "
"of an operation. In our ``readInt`` example, we might wish to update the "
"vector only if the input is a valid integer (i.e. all digits). As a first "
"attempt, we could try the following, returning a ``Bool`` which indicates "
"success:"
msgstr ""

#: ..\..\effects\depeff.rst:80
msgid ""
"Unfortunately, this will not type check because the vector does not get "
"extended in both branches of the ``case``!"
msgstr ""

#: ..\..\effects\depeff.rst:89
msgid ""
"Clearly, the size of the resulting vector depends on whether or not the "
"value read from the user was valid. We can express this in the type:"
msgstr ""

#: ..\..\effects\depeff.rst:103
msgid ""
"The notation ``{ xs ==> res xs’ } Eff a`` in a type means that the effects "
"available are updated from ``xs`` to ``xs’``, *and* the resulting effects "
"``xs’`` may depend on the result of the operation ``res``, of type ``a``. "
"Here, the resulting effects are computed from the result ``ok``—if ``True``,"
" the vector is extended, otherwise it remains the same."
msgstr ""

#: ..\..\effects\depeff.rst:110
msgid ""
"When using the function, we will naturally have to check its return value in"
" order to know what the new set of effects is. For example, to read a set "
"number of values into a vector, we could write the following:"
msgstr ""

#: ..\..\effects\depeff.rst:124
msgid ""
"The ``case`` analysis on the result of ``readInt`` means that we know in "
"each branch whether reading the integer succeeded, and therefore how many "
"values still need to be read into the vector. What this means in practice is"
" that the type system has verified that a necessary dynamic check (i.e. "
"whether reading a value succeeded) has indeed been done."
msgstr ""

#: ..\..\effects\depeff.rst:131
msgid ""
"Only ``case`` will work here. We cannot use ``if/then/else`` because the "
"``then`` and ``else`` branches must have the same type. The ``case`` "
"construct, however, abstracts over the value being inspected in the type of "
"each branch."
msgstr ""

#: ..\..\effects\depeff.rst:137
msgid "File Management"
msgstr ""

#: ..\..\effects\depeff.rst:139
msgid ""
"A practical use for dependent effects is in specifying resource usage "
"protocols and verifying that they are executed correctly. For example, file "
"management follows a resource usage protocol with the following (informally "
"specified) requirements:"
msgstr ""

#: ..\..\effects\depeff.rst:144
msgid "It is necessary to open a file for reading before reading it"
msgstr ""

#: ..\..\effects\depeff.rst:146
msgid ""
"Opening may fail, so the programmer should check whether opening was "
"successful"
msgstr ""

#: ..\..\effects\depeff.rst:149
msgid ""
"A file which is open for reading must not be written to, and vice versa"
msgstr ""

#: ..\..\effects\depeff.rst:152
msgid "When finished, an open file handle should be closed"
msgstr ""

#: ..\..\effects\depeff.rst:154
msgid "When a file is closed, its handle should no longer be used"
msgstr ""

#: ..\..\effects\depeff.rst:156
msgid ""
"These requirements can be expressed formally in , by creating a ``FILE_IO`` "
"effect parameterised over a file handle state, which is either empty, open "
"for reading, or open for writing. The ``FILE_IO`` effect’s definition is "
"given below. Note that this effect is mainly for illustrative "
"purposes—typically we would also like to support random access files and "
"better reporting of error conditions."
msgstr ""

#: ..\..\effects\depeff.rst:185
msgid "In particular, consider the type of ``open``:"
msgstr ""

#: ..\..\effects\depeff.rst:193
msgid ""
"This returns a ``Bool`` which indicates whether opening the file was "
"successful. The resulting state depends on whether the operation was "
"successful; if so, we have a file handle open for the stated purpose, and if"
" not, we have no file handle. By ``case`` analysis on the result, we "
"continue the protocol accordingly."
msgstr ""

#: ..\..\effects\depeff.rst:210
msgid ""
"Given a function ``readFile``, above, which reads from an open file until "
"reaching the end, we can write a program which opens a file, reads it, then "
"displays the contents and closes it, as follows, correctly following the "
"protocol:"
msgstr ""

#: ..\..\effects\depeff.rst:223
msgid ""
"The type of ``dumpFile``, with ``FILE_IO ()`` in its effect list, indicates "
"that any use of the file resource will follow the protocol correctly (i.e. "
"it both begins and ends with an empty resource). If we fail to follow the "
"protocol correctly (perhaps by forgetting to close the file, failing to "
"check that ``open`` succeeded, or opening the file for writing) then we will"
" get a compile-time error. For example, changing ``open name Read`` to "
"``open name Write`` yields a compile-time error of the following form:"
msgstr ""

#: ..\..\effects\depeff.rst:240
msgid ""
"In other words: when reading a file, we need a file which is open for "
"reading, but the effect list contains a ``FILE_IO`` effect carrying a file "
"open for writing."
msgstr ""

#: ..\..\effects\depeff.rst:245
msgid "Pattern-matching bind"
msgstr ""

#: ..\..\effects\depeff.rst:247
msgid ""
"It might seem that having to test each potentially failing operation with a "
"``case`` clause could lead to ugly code, with lots of nested case blocks. "
"Many languages support exceptions to improve this, but unfortunately "
"exceptions may not allow completely clean resource management—for example, "
"guaranteeing that any ``open`` which did succeed has a corresponding close."
msgstr ""

#: ..\..\effects\depeff.rst:254
msgid "Idris supports *pattern-matching* bindings, such as the following:"
msgstr ""

#: ..\..\effects\depeff.rst:263
msgid ""
"This also has a problem: we are no longer dealing with the case where "
"opening a file failed! The solution is to extend the pattern-matching "
"binding syntax to give brief clauses for failing matches. Here, for example,"
" we could write:"
msgstr ""

#: ..\..\effects\depeff.rst:275
msgid ""
"This is exactly equivalent to the definition with the explicit ``case``. In "
"general, in a ``do``-block, the syntax:"
msgstr ""

#: ..\..\effects\depeff.rst:283
msgid "is desugared to"
msgstr ""

#: ..\..\effects\depeff.rst:292
msgid ""
"There can be several ``alternatives``, separated by a vertical bar ``|``. "
"For example, there is a ``SYSTEM`` effect which supports reading command "
"line arguments, among other things (see Appendix :ref:`sect-appendix`). To "
"read command line arguments, we can use ``getArgs``:"
msgstr ""

#: ..\..\effects\depeff.rst:302
msgid ""
"A main program can read command line arguments as follows, where in the list"
" which is returned, the first element ``prog`` is the executable name and "
"the second is an expected argument:"
msgstr ""

#: ..\..\effects\depeff.rst:313
msgid ""
"Unfortunately, this will not fail gracefully if no argument is given, or if "
"too many arguments are given. We can use pattern matching bind alternatives "
"to give a better (more informative) error:"
msgstr ""

#: ..\..\effects\depeff.rst:326
msgid ""
"If ``getArgs`` does not return something of the form ``[prog, arg]`` the "
"alternative which does match is executed instead, and that value returned."
msgstr ""
