# 
msgid ""
msgstr ""
"Project-Id-Version: Idris 0.9.17\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-05-20 17:05+0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\effects\state.rst:5
msgid "State"
msgstr ""

#: ..\..\effects\state.rst:7
msgid ""
"Many programs, even pure programs, can benefit from locally mutable state. "
"For example, consider a program which tags binary tree nodes with a counter,"
" by an inorder traversal (i.e. counting depth first, left to right). This "
"would perform something like the following:"
msgstr ""

#: ..\..\effects\state.rst:12
msgid "|image|"
msgstr ""

#: ..\..\effects\state.rst:14
msgid ""
"We can describe binary trees with the following data type ``BTree`` and "
"``testTree`` to represent the example input above:"
msgstr ""

#: ..\..\effects\state.rst:29
msgid ""
"Then our function to implement tagging, beginning to tag with a specific "
"value ``i``, has the following type:"
msgstr ""

#: ..\..\effects\state.rst:37
msgid "First attempt"
msgstr ""

#: ..\..\effects\state.rst:39
msgid ""
"Naïvely, we can implement ``treeTag`` by implementing a helper function "
"which propagates a counter, returning the result of the count for each "
"subtree:"
msgstr ""

#: ..\..\effects\state.rst:56
msgid "This gives the expected result when run at the REPL prompt:"
msgstr ""

#: ..\..\effects\state.rst:67
msgid ""
"This works as required, but there are several problems when we try to scale "
"this to larger programs. It is error prone, because we need to ensure that "
"state is propagated correctly to the recursive calls (i.e. passing the "
"appropriate ``i`` or ``i’``). It is hard to read, because the functional "
"details are obscured by the state propagation. Perhaps most importantly, "
"there is a common programming pattern here which should be abstracted but "
"instead has been implemented by hand. There is local mutable state (the "
"counter) which we have had to make explicit."
msgstr ""

#: ..\..\effects\state.rst:78
msgid "Introducing ``Effects``"
msgstr ""

#: ..\..\effects\state.rst:80
msgid ""
"Idris provides a library, ``Effects`` [3]_, which captures this pattern and "
"many others involving effectful computation [1]_. An effectful program ``f``"
" has a type of the following form:"
msgstr ""

#: ..\..\effects\state.rst:88
msgid ""
"That is, the return type gives the effects that ``f`` supports (``effs``, of"
" type ``List EFFECT``) and the type the computation returns ``t``. So, our "
"``treeTagAux`` helper could be written with the following type:"
msgstr ""

#: ..\..\effects\state.rst:97
msgid ""
"That is, ``treeTagAux`` has access to an integer state, because the list of "
"available effects includes ``STATE Int``. ``STATE`` is declared as follows "
"in the module ``Effect.State`` (that is, we must ``import Effect.State`` to "
"be able to use it):"
msgstr ""

#: ..\..\effects\state.rst:106
msgid ""
"It is an effect parameterised by a type (by convention, we write effects in "
"all capitals). The ``treeTagAux`` function is an effectful program which "
"builds a new tree tagged with ``Ints``, and is implemented as follows:"
msgstr ""

#: ..\..\effects\state.rst:121
msgid ""
"There are several remarks to be made about this implementation. Essentially,"
" it hides the state, which can be accessed using ``get`` and updated using "
"``put``, but it introduces several new features. Specifically, it uses "
"``do``-notation, binding variables with ``<-``, and a ``pure`` function. "
"There is much to be said about these features, but for our purposes, it "
"suffices to know the following:"
msgstr ""

#: ..\..\effects\state.rst:128
msgid "``do`` blocks allow effectful operations to be sequenced."
msgstr ""

#: ..\..\effects\state.rst:133
msgid "``x <- e`` binds the result of an effectful operation ``e`` to a"
msgstr ""

#: ..\..\effects\state.rst:131
msgid ""
"variable ``x``. For example, in the above code, ``treeTagAux l`` is an "
"effectful operation returning ``BTree (Int, a)``, so ``l’`` has type ``BTree"
" (Int, a)``."
msgstr ""

#: ..\..\effects\state.rst:136
msgid "``pure e`` turns a pure value ``e`` into the result of an effectful"
msgstr ""

#: ..\..\effects\state.rst:136 ..\..\effects\state.rst:343
msgid "operation."
msgstr ""

#: ..\..\effects\state.rst:138
msgid ""
"The ``get`` and ``put`` functions read and write a state ``t``, assuming "
"that the ``STATE t`` effect is available. They have the following types, "
"polymorphic in the state ``t`` they manage:"
msgstr ""

#: ..\..\effects\state.rst:147
msgid ""
"A program in ``Eff`` can call any other function in ``Eff`` provided that "
"the calling function supports at least the effects required by the called "
"function. In this case, it is valid for ``treeTagAux`` to call both ``get`` "
"and ``put`` because all three functions support the ``STATE Int`` effect."
msgstr ""

#: ..\..\effects\state.rst:153
msgid ""
"Programs in ``Eff`` are run in some underlying *computation context*, using "
"the ``run`` or ``runPure`` function. Using ``runPure``, which runs an "
"effectful program in the identity context, we can write the ``treeTag`` "
"function as follows, using ``put`` to initialise the state:"
msgstr ""

#: ..\..\effects\state.rst:165
msgid ""
"We could also run the program in an impure context such as ``IO``, without "
"changing the definition of ``treeTagAux``, by using ``run`` instead of "
"``runPure``:"
msgstr ""

#: ..\..\effects\state.rst:178
msgid ""
"Note that the definition of ``treeTagAux`` is exactly as before. For "
"reference, this complete program (including a ``main`` to run it) is shown "
"in Listing [introprog]."
msgstr ""

#: ..\..\effects\state.rst:220
msgid "Effects and Resources"
msgstr ""

#: ..\..\effects\state.rst:222
msgid ""
"Each effect is associated with a *resource*, which is initialised before an "
"effectful program can be run. For example, in the case of ``STATE Int`` the "
"corresponding resource is the integer state itself. The types of ``runPure``"
" and ``run`` show this (slightly simplified here for illustrative purposes):"
msgstr ""

#: ..\..\effects\state.rst:233
msgid ""
"The ``env`` argument is implicit, and initialised automatically where "
"possible using default values given by instances of the following type "
"class:"
msgstr ""

#: ..\..\effects\state.rst:242
msgid ""
"Instances of ``Default`` are defined for all primitive types, and many "
"library types such as ``List``, ``Vect``, ``Maybe``, pairs, etc. However, "
"where no default value exists for a resource type (for example, you may want"
" a ``STATE`` type for which there is no ``Default`` instance) the resource "
"environment can be given explicitly using one of the following functions:"
msgstr ""

#: ..\..\effects\state.rst:254
msgid ""
"To be well-typed, the environment must contain resources corresponding "
"exactly to the effects in ``xs``. For example, we could also have "
"implemented ``treeTag`` by initialising the state as follows:"
msgstr ""

#: ..\..\effects\state.rst:264
msgid "Labelled Effects"
msgstr ""

#: ..\..\effects\state.rst:266
msgid ""
"What if we have more than one state, especially more than one state of the "
"same type? How would ``get`` and ``put`` know which state they should be "
"referring to? For example, how could we extend the tree tagging example such"
" that it additionally counts the number of leaves in the tree? One "
"possibility would be to change the state so that it captured both of these "
"values, e.g.:"
msgstr ""

#: ..\..\effects\state.rst:278
msgid ""
"Doing this, however, ties the two states together throughout (as well as not"
" indicating which integer is which). It would be nice to be able to call "
"effectful programs which guaranteed only to access one of the states, for "
"example. In a larger application, this becomes particularly important."
msgstr ""

#: ..\..\effects\state.rst:284
msgid ""
"The library therefore allows effects in general to be *labelled* so that "
"they can be referred to explicitly by a particular name. This allows "
"multiple effects of the same type to be included. We can count leaves and "
"update the tag separately, by labelling them as follows:"
msgstr ""

#: ..\..\effects\state.rst:295
msgid ""
"The ``:::`` operator allows an arbitrary label to be given to an effect.  "
"This label can be any type—it is simply used to identify an effect uniquely."
" Here, we have used a symbol type. In general ``’name`` introduces a new "
"symbol, the only purpose of which is to disambiguate values [2]_."
msgstr ""

#: ..\..\effects\state.rst:301
msgid ""
"When an effect is labelled, its operations are also labelled using the "
"``:-`` operator. In this way, we can say explicitly which state we mean when"
" using ``get`` and ``put``. The tree tagging program which also counts "
"leaves can be written as follows:"
msgstr ""

#: ..\..\effects\state.rst:318
msgid ""
"The ``update`` function here is a combination of ``get`` and ``put``, "
"applying a function to the current state."
msgstr ""

#: ..\..\effects\state.rst:325
msgid ""
"Finally, our top level ``treeTag`` function now returns a pair of the number"
" of leaves, and the new tree. Resources for labelled effects are intialised "
"using the ``:=`` operator (reminisicent of assignment in an imperative "
"language):"
msgstr ""

#: ..\..\effects\state.rst:338
msgid "To summarise, we have:"
msgstr ""

#: ..\..\effects\state.rst:340
msgid "``:::`` to convert an effect to a labelled effect."
msgstr ""

#: ..\..\effects\state.rst:343
msgid "``:-`` to convert an effectful operation to a labelled effectful"
msgstr ""

#: ..\..\effects\state.rst:345
msgid "``:=`` to initialise a resource for a labelled effect."
msgstr ""

#: ..\..\effects\state.rst:347
msgid ""
"Or, more formally with their types (slightly simplified to account only for "
"the situation where available effects are not updated):"
msgstr ""

#: ..\..\effects\state.rst:356
msgid ""
"Here, ``LRes`` is simply the resource type associated with a labelled "
"effect. Note that labels are polymorphic in the label type ``lbl``. Hence, a"
" label can be anything—a string, an integer, a type, etc."
msgstr ""

#: ..\..\effects\state.rst:361
msgid "``!``-notation"
msgstr ""

#: ..\..\effects\state.rst:363
msgid ""
"In many cases, using ``do``-notation can make programs unnecessarily "
"verbose, particularly in cases where the value bound is used once, "
"immediately. The following program returns the length of the ``String`` "
"stored in the state, for example:"
msgstr ""

#: ..\..\effects\state.rst:374
msgid ""
"This seems unnecessarily verbose, and it would be nice to program in a more "
"direct style in these cases. provides ``!``-notation to help with this. The "
"above program can be written instead as:"
msgstr ""

#: ..\..\effects\state.rst:383
msgid ""
"The notation ``!expr`` means that the expression ``expr`` should be "
"evaluated and then implicitly bound. Conceptually, we can think of ``!`` as "
"being a prefix function with the following type:"
msgstr ""

#: ..\..\effects\state.rst:391
msgid ""
"Note, however, that it is not really a function, merely syntax! In practice,"
" a subexpression ``!expr`` will lift ``expr`` as high as possible within its"
" current scope, bind it to a fresh name ``x``, and replace ``!expr`` with "
"``x``. Expressions are lifted depth first, left to right. In practice, "
"``!``-notation allows us to program in a more direct style, while still "
"giving a notational clue as to which expressions are effectful."
msgstr ""

#: ..\..\effects\state.rst:399
msgid "For example, the expression:"
msgstr ""

#: ..\..\effects\state.rst:405
msgid "is lifted to:"
msgstr ""

#: ..\..\effects\state.rst:415
msgid "Syntactic Sugar and ``Eff``"
msgstr ""

#: ..\..\effects\state.rst:417
msgid ""
"By now, you may be wondering about the syntax we are using for ``Eff``, "
"because it doesn’t look like a normal type! (If not, you may safely skip "
"this section and return to it later.) In fact, the type of ``Eff`` is the "
"following:"
msgstr ""

#: ..\..\effects\state.rst:427
msgid ""
"This is more general than the types we have been writing so far. It is "
"parameterised over a result type ``x``, as we have already seen, but also a "
"``List EFFECT`` and a function type ``x -> List EFFECT``."
msgstr ""

#: ..\..\effects\state.rst:431
msgid ""
"These additional parameters are the list of *input* effects, and a list of "
"*output* effects, computed from the result of an effectful operation.  That "
"is: running an effectful program can change the set of effects available! "
"This is a particularly powerful idea, and we will see its consequences in "
"more detail later. Some examples of operations which can change the set of "
"available effects are:"
msgstr ""

#: ..\..\effects\state.rst:439
msgid "Updating a state containing a dependent type (for example adding an"
msgstr ""

#: ..\..\effects\state.rst:439
msgid "element to a vector)."
msgstr ""

#: ..\..\effects\state.rst:441
msgid ""
"Opening a file for reading is an effect, but whether the file really *is* "
"open afterwards depends on whether the file was successfully opened."
msgstr ""

#: ..\..\effects\state.rst:445
msgid ""
"Closing a file means that reading from the file should no longer be "
"possible."
msgstr ""

#: ..\..\effects\state.rst:448
msgid ""
"While powerful, this can make uses of the ``Eff`` type hard to read. "
"Therefore, the library provides syntactic sugar which is translated such "
"that:"
msgstr ""

#: ..\..\effects\state.rst:456
msgid "is expanded to"
msgstr ""

#: ..\..\effects\state.rst:462
msgid ""
"i.e. the set of effects remains the same on output. This suffices for the "
"``STATE`` example we have seen so far, and for many useful side-effecting "
"programs. We could also have written ``treeTagAux`` with the expanded type:"
msgstr ""

#: ..\..\effects\state.rst:472
msgid "Later, we will see programs which update effects:"
msgstr ""

#: ..\..\effects\state.rst:478 ..\..\effects\state.rst:498
msgid "which is expanded to"
msgstr ""

#: ..\..\effects\state.rst:484
msgid ""
"i.e. the set of effects is updated to ``xs’`` (think of a transition in a "
"state machine). There is, for example, a version of ``put`` which updates "
"the type of the state:"
msgstr ""

#: ..\..\effects\state.rst:492
msgid "Also, we have:"
msgstr ""

#: ..\..\effects\state.rst:504
msgid ""
"i.e. the set of effects is updated according to the result of the operation "
"``res``."
msgstr ""

#: ..\..\effects\state.rst:507
msgid ""
"The earlier paper [3]_ describes the essential implementation details, "
"although the library presented there is an earlier version which is less "
"powerful than that presented in this tutorial."
msgstr ""

#: ..\..\effects\state.rst:511
msgid "In practice, ``’name`` simply introduces a new empty type"
msgstr ""

#: ..\..\effects\state.rst:513
msgid ""
"Edwin Brady. 2013. Programming and reasoning with algebraic effects and "
"dependent types. SIGPLAN Not. 48, 9 (September 2013), 133-144. "
"DOI=10.1145/2544174.2500581 http://doi.acm.org/10.1145/2544174.2500581"
msgstr ""
